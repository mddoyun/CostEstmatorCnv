# 56. 액티비티 객체 수동 수량입력 및 자동 수량계산 구현

**날짜**: 2025-11-04
**작업자**: Claude Code
**관련 이슈**: 액티비티 객체의 수량을 사용자가 직접 입력하거나 산식으로 지정할 수 있는 기능 추가

## 작업 개요

액티비티 객체 탭에 두 가지 새로운 기능을 추가했습니다:
1. **수동 수량입력**: 사용자가 직접 값을 입력하거나 산식을 지정
2. **자동 수량계산**: 모든 액티비티 객체의 수량을 재계산

## 배경 및 요구사항

### 기존 동작

**자동 생성(액티비티코드 기준) 버튼**:
- 액티비티 코드별로 액티비티 객체 자동 생성
- `AO.actual_duration = Activity.duration_per_unit * CI.quantity` 자동 계산
- 모든 객체가 같은 자동 계산 로직 사용

### 새로운 요구사항

**사용자 요청**:
> "일단 '자동 생성(액티비티코드 기준)' 버튼을 누르면 액티비티 객체가 생성이 되거든. 그때 자동으로 액티비티 코드에 정의되어있는 Activity.duration_per_unit 값과 CI.quantity 속성을 기준으로 두 값을 곱해서 AO.actual_duration 값이 계산되어져. 그런데 이 액티비티 객체별로 자동으로 계산된 값이 아니라 사용자가 직접 AO.quantity 값을 지정하거나 산식을 지정할 수 있어야해."

**세부 요구사항**:

1. **수동 수량입력 모드**:
   - **직접 입력**: 사용자가 숫자 직접 입력
   - **산식 입력**: 템플릿 표현식 사용 (예: `{CI.quantity} * 2.5`)

2. **자동 수량계산 로직** (3가지 경우):
   - **Case 1 - 자동 계산**: `AO.quantity = Activity.duration_per_unit * CI.quantity`
   - **Case 2 - 수동 직접입력**: 사용자가 입력한 값 유지 (재계산 건너뜀)
   - **Case 3 - 수동 산식입력**: 저장된 산식을 재평가하여 `AO.quantity` 업데이트

## 구현 내용

### 1. HTML 버튼 추가

**파일**: `connections/templates/revit_control.html`
**위치**: Line 2747-2758

```html
<div class="control-section">
    <h4 class="control-section-title">수량속성 할당</h4>

    <!-- 새로 추가된 버튼 -->
    <button id="ao-auto-quantity-calc-btn"
            style="width: 100%; margin-bottom: 4px;
                   background-color: #007bff; color: white;
                   border: 1px solid #007bff;">
        자동 수량계산
    </button>

    <button id="ao-manual-quantity-input-btn"
            style="width: 100%; margin-bottom: 4px;
                   background-color: #28a745; color: white;
                   border: 1px solid #28a745;">
        수동 수량입력
    </button>

    <!-- 기존 버튼들... -->
</div>
```

### 2. 수동 수량입력 모달 구현

**파일**: `connections/static/connections/activity_object_manager.js`
**함수**: `showManualAoQuantityInputModal()`
**위치**: Line 1396-1685

#### 기능 개요

- 코스트아이템의 수동 수량입력 모달과 동일한 패턴 적용
- 두 가지 입력 모드 지원: 직접 입력 vs 산식 입력
- 선택된 모든 액티비티 객체에 일괄 적용

#### 주요 코드

```javascript
function showManualAoQuantityInputModal() {
    const selectedActivityObjects = Array.from(selectedAoIds || []);

    if (!selectedActivityObjects || selectedActivityObjects.length === 0) {
        showToast('항목을 먼저 선택하세요.', 'error');
        return;
    }

    const selectedItems = window.loadedActivityObjects.filter(
        item => selectedActivityObjects.includes(item.id)
    );

    // 모달 생성
    const modal = document.createElement('div');
    modal.className = 'manual-ao-quantity-input-modal';
    modal.innerHTML = `
        <div class="modal-content">
            <h3>수동 수량입력 (액티비티 객체)</h3>

            <!-- 모드 선택 라디오 버튼 -->
            <div class="input-mode-selector">
                <label>
                    <input type="radio" name="ao-quantity-mode"
                           value="direct" checked>
                    직접 입력 (숫자)
                </label>
                <label>
                    <input type="radio" name="ao-quantity-mode"
                           value="formula">
                    산식 입력
                </label>
            </div>

            <!-- 직접 입력 필드 -->
            <div id="ao-direct-input-section" class="input-section">
                <label>수량 값:</label>
                <input type="number" id="ao-direct-quantity-value"
                       placeholder="숫자를 입력하세요" step="0.01">
            </div>

            <!-- 산식 입력 필드 -->
            <div id="ao-formula-input-section"
                 class="input-section" style="display: none;">
                <label>수량 산식:</label>
                <textarea id="ao-formula-quantity-expression"
                          placeholder="예: {CI.quantity} * 2.5"></textarea>

                <!-- 속성 선택 드롭다운 -->
                <select id="ao-property-dropdown">
                    <option value="">사용 가능한 속성</option>
                    <!-- ActivityObject 속성 -->
                    <optgroup label="ActivityObject">
                        <option value="{AO.id}">AO.id</option>
                        <option value="{AO.quantity}">AO.quantity</option>
                        <option value="{AO.actual_duration}">AO.actual_duration</option>
                    </optgroup>
                    <!-- Activity 속성 -->
                    <optgroup label="Activity">
                        <option value="{Activity.code}">Activity.code</option>
                        <option value="{Activity.duration_per_unit}">Activity.duration_per_unit</option>
                    </optgroup>
                    <!-- CostItem, QuantityMember, MemberMark, BIM 속성... -->
                </select>
                <button id="ao-insert-property-btn">삽입</button>
            </div>

            <!-- 선택된 항목 테이블 -->
            <div class="selected-items-preview">
                <h4>선택된 항목 (${selectedItems.length}개)</h4>
                <table><!-- 항목 목록 표시 --></table>
            </div>

            <!-- 버튼 -->
            <div class="modal-buttons">
                <button id="ao-manual-quantity-apply-btn">적용</button>
                <button id="ao-manual-quantity-cancel-btn">취소</button>
            </div>
        </div>
    `;

    document.body.appendChild(modal);

    // 이벤트 리스너 설정
    setupModalEventListeners();
}
```

#### 모드 전환 로직

```javascript
// 라디오 버튼 변경 시 입력 필드 표시/숨김
modeRadios.forEach(radio => {
    radio.addEventListener('change', (e) => {
        const mode = e.target.value;
        if (mode === 'direct') {
            directSection.style.display = 'block';
            formulaSection.style.display = 'none';
        } else {
            directSection.style.display = 'none';
            formulaSection.style.display = 'block';
        }
    });
});
```

#### 적용 로직

```javascript
// 적용 버튼 클릭
applyBtn.addEventListener('click', async () => {
    const mode = document.querySelector(
        'input[name="ao-quantity-mode"]:checked'
    ).value;

    let updates = [];

    if (mode === 'direct') {
        // Case 2: 직접 입력 모드
        const value = parseFloat(directInput.value);
        if (isNaN(value)) {
            showToast('유효한 숫자를 입력하세요.', 'error');
            return;
        }

        updates = selectedItems.map(item => ({
            id: item.id,
            quantity: value,
            is_manual: true,
            manual_formula: null,
            quantity_expression: JSON.stringify({
                mode: 'direct',
                value: value
            })
        }));

    } else if (mode === 'formula') {
        // Case 3: 산식 입력 모드
        const formula = formulaInput.value.trim();
        if (!formula) {
            showToast('산식을 입력하세요.', 'error');
            return;
        }

        updates = selectedItems.map(item => {
            const context = buildActivityObjectContext(item);
            const calculatedValue = evaluateQuantityFormula(formula, context);

            return {
                id: item.id,
                quantity: calculatedValue,
                is_manual: true,
                manual_formula: formula,
                quantity_expression: JSON.stringify({
                    mode: 'formula',
                    formula: formula
                })
            };
        });
    }

    // 서버에 저장
    await saveManualAoQuantities(updates);
});
```

### 3. Context Builder 구현

**함수**: `buildActivityObjectContext(ao)`
**위치**: Line 2118-2213

#### 역할

액티비티 객체와 관련된 모든 속성을 수집하여 산식 평가에 사용할 컨텍스트 객체 생성

#### 구현 코드

```javascript
function buildActivityObjectContext(ao) {
    const context = {};

    // 1. ActivityObject 속성
    context['AO.id'] = ao.id || '';
    context['AO.quantity'] = ao.quantity || 0;
    context['AO.actual_duration'] = ao.actual_duration || 0;
    context['AO.start_date'] = ao.start_date || '';
    context['AO.end_date'] = ao.end_date || '';
    context['AO.actual_start_date'] = ao.actual_start_date || '';
    context['AO.actual_end_date'] = ao.actual_end_date || '';

    // 2. Activity 속성
    if (ao.activity) {
        context['Activity.id'] = ao.activity.id || '';
        context['Activity.code'] = ao.activity.code || '';
        context['Activity.name'] = ao.activity.name || '';
        context['Activity.duration_per_unit'] = ao.activity.duration_per_unit || 0;
        context['Activity.unit'] = ao.activity.unit || '';
    }

    // 3. CostItem 속성
    if (ao.cost_item) {
        context['CI.id'] = ao.cost_item.id || '';
        context['CI.quantity'] = ao.cost_item.quantity || 0;
        context['CI.group_name'] = ao.cost_item.group_name || '';

        // 4. CostCode 속성 (CostItem을 통해 접근)
        if (ao.cost_item.cost_code) {
            context['CostCode.code'] = ao.cost_item.cost_code.code || '';
            context['CostCode.name'] = ao.cost_item.cost_code.name || '';
            context['CostCode.detail_code'] = ao.cost_item.cost_code.detail_code || '';
        }

        // 5. QuantityMember 속성 (CostItem을 통해 접근)
        if (ao.cost_item.quantity_member) {
            const qm = ao.cost_item.quantity_member;
            context['QM.id'] = qm.id || '';
            context['QM.name'] = qm.name || '';
            context['QM.volume'] = qm.volume || 0;
            context['QM.area'] = qm.area || 0;
            context['QM.length'] = qm.length || 0;

            // QM.properties.* 추가
            if (qm.properties && typeof qm.properties === 'object') {
                Object.entries(qm.properties).forEach(([key, value]) => {
                    context[`QM.properties.${key}`] = value;
                });
            }

            // 6. MemberMark 속성 (QuantityMember를 통해 접근)
            if (qm.member_mark) {
                context['MM.id'] = qm.member_mark.id || '';
                context['MM.mark'] = qm.member_mark.mark || '';
            }

            // 7. BIM Raw Data (RawElement를 통해 접근)
            if (qm.raw_element_ids && qm.raw_element_ids.length > 0) {
                const firstReId = qm.raw_element_ids[0];
                const rawElement = window.allRevitData?.find(
                    re => re.id === firstReId
                );

                if (rawElement) {
                    context['BIM.Category'] = rawElement.Category || '';
                    context['BIM.Family'] = rawElement.Family || '';
                    context['BIM.Type'] = rawElement.Type || '';
                    context['BIM.Level'] = rawElement.Level || '';

                    // BIM.Parameters.*
                    if (rawElement.Parameters) {
                        Object.entries(rawElement.Parameters).forEach(([key, value]) => {
                            context[`BIM.Parameters.${key}`] = value;
                        });
                    }

                    // BIM.TypeParameters.*
                    if (rawElement.TypeParameters) {
                        Object.entries(rawElement.TypeParameters).forEach(([key, value]) => {
                            context[`BIM.TypeParameters.${key}`] = value;
                        });
                    }
                }
            }
        }
    }

    console.log('[DEBUG][buildActivityObjectContext] Built context:', context);
    return context;
}
```

#### Context 구조 예시

```javascript
{
    // ActivityObject
    'AO.id': '123e4567-e89b-12d3-a456-426614174000',
    'AO.quantity': 125.5,
    'AO.actual_duration': 10.5,

    // Activity
    'Activity.code': 'ACT-001',
    'Activity.name': '거푸집 설치',
    'Activity.duration_per_unit': 0.5,

    // CostItem
    'CI.id': 'ci-123',
    'CI.quantity': 250.0,

    // CostCode
    'CostCode.code': 'CC-001',
    'CostCode.name': '거푸집',

    // QuantityMember
    'QM.volume': 100.0,
    'QM.area': 500.0,
    'QM.properties.두께': 200,

    // MemberMark
    'MM.mark': 'S-1',

    // BIM
    'BIM.Category': '벽',
    'BIM.Parameters.길이': 5000
}
```

### 4. 자동 수량계산 구현

**함수**: `recalculateAllAoQuantities()`
**위치**: Line 2027-2113

#### 기능 개요

모든 액티비티 객체의 수량을 재계산하는 기능으로, 3가지 경우를 구분하여 처리:
1. **자동 계산**: 기본 수식으로 재계산
2. **수동 직접입력**: 건너뜀 (사용자 값 유지)
3. **수동 산식입력**: 산식 재평가

#### 구현 코드

```javascript
async function recalculateAllAoQuantities() {
    if (!currentProjectId) {
        showToast('프로젝트를 먼저 선택하세요.', 'error');
        return;
    }

    if (!confirm('모든 액티비티 객체의 수량을 재계산하시겠습니까?\n(수동 직접입력 값은 유지되고, 산식은 재평가됩니다.)')) {
        return;
    }

    console.log('[DEBUG][recalculateAllAoQuantities] Starting auto calculation...');

    try {
        // 1. 모든 액티비티 객체 로드
        const response = await fetch(
            `/connections/api/activity-objects/${currentProjectId}/`,
            {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': getCSRFToken()
                }
            }
        );

        if (!response.ok) {
            throw new Error('액티비티 객체 로드 실패');
        }

        const allAos = await response.json();
        console.log(`[DEBUG][recalculateAllAoQuantities] Loaded ${allAos.length} activity objects`);

        let updatedCount = 0;
        let skippedCount = 0;
        let errorCount = 0;

        // 2. 각 액티비티 객체 처리
        for (const ao of allAos) {
            let newQuantity = null;

            // 2.1 수동 입력 모드 확인
            if (ao.is_manual && !ao.manual_formula) {
                // Case 2: 수동 직접입력 - 건너뜀
                console.log(`[DEBUG] Skipping direct input AO: ${ao.id}`);
                skippedCount++;
                continue;

            } else if (ao.is_manual && ao.manual_formula) {
                // Case 3: 수동 산식입력 - 산식 재평가
                console.log(`[DEBUG] Re-evaluating formula for AO: ${ao.id}`);
                console.log(`[DEBUG] Formula: ${ao.manual_formula}`);

                const aoContext = buildActivityObjectContext(ao);
                newQuantity = evaluateQuantityFormula(ao.manual_formula, aoContext);

                console.log(`[DEBUG] Formula result: ${newQuantity}`);

            } else {
                // Case 1: 자동 계산
                console.log(`[DEBUG] Auto-calculating for AO: ${ao.id}`);

                const durationPerUnit = ao.activity?.duration_per_unit || 0;
                const ciQuantity = ao.cost_item?.quantity || 0;
                newQuantity = durationPerUnit * ciQuantity;

                console.log(`[DEBUG] Auto calc: ${durationPerUnit} * ${ciQuantity} = ${newQuantity}`);
            }

            // 3. 서버에 업데이트
            if (newQuantity !== null) {
                try {
                    const updateResponse = await fetch(
                        `/connections/api/activity-objects/${currentProjectId}/${ao.id}/`,
                        {
                            method: 'PUT',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-CSRFToken': getCSRFToken()
                            },
                            body: JSON.stringify({
                                quantity: newQuantity
                            })
                        }
                    );

                    if (!updateResponse.ok) {
                        throw new Error(`Update failed for AO: ${ao.id}`);
                    }

                    updatedCount++;

                } catch (error) {
                    console.error(`[ERROR] Failed to update AO ${ao.id}:`, error);
                    errorCount++;
                }
            }
        }

        // 4. 결과 표시 및 재로드
        console.log(`[DEBUG][recalculateAllAoQuantities] Complete:`, {
            total: allAos.length,
            updated: updatedCount,
            skipped: skippedCount,
            errors: errorCount
        });

        showToast(
            `자동 수량계산 완료: ${updatedCount}개 업데이트, ${skippedCount}개 건너뜀`,
            'success'
        );

        // 5. 테이블 새로고침
        await loadActivityObjects();

    } catch (error) {
        console.error('[ERROR][recalculateAllAoQuantities]:', error);
        showToast('자동 수량계산 중 오류가 발생했습니다.', 'error');
    }
}
```

#### 로직 흐름도

```
┌─────────────────────────────────┐
│ recalculateAllAoQuantities()    │
└─────────────┬───────────────────┘
              │
              ├─→ 확인 대화상자
              │
              ├─→ 모든 AO 로드 (GET API)
              │
              ├─→ For each AO:
              │   │
              │   ├─→ if (is_manual && !manual_formula)
              │   │   └─→ Case 2: Skip (직접입력 값 유지)
              │   │
              │   ├─→ else if (is_manual && manual_formula)
              │   │   ├─→ Case 3: Re-evaluate formula
              │   │   ├─→ buildActivityObjectContext(ao)
              │   │   └─→ evaluateQuantityFormula(formula, context)
              │   │
              │   └─→ else
              │       └─→ Case 1: Auto calculation
              │           └─→ duration_per_unit * CI.quantity
              │
              ├─→ PUT /api/activity-objects/{id}/ (업데이트)
              │
              └─→ loadActivityObjects() (재로드)
```

### 5. 이벤트 리스너 등록

**파일**: `connections/static/connections/activity_object_manager.js`
**위치**: Line 83-91

```javascript
// 자동 수량계산 버튼
document.getElementById('ao-auto-quantity-calc-btn')
    ?.addEventListener('click', recalculateAllAoQuantities);

console.log('[DEBUG][activity_object_manager.js] ao-auto-quantity-calc-btn listener registered');

// 수동 수량입력 버튼
document.getElementById('ao-manual-quantity-input-btn')
    ?.addEventListener('click', showManualAoQuantityInputModal);

console.log('[DEBUG][activity_object_manager.js] ao-manual-quantity-input-btn listener registered');
```

## 데이터 모델 변경

### ActivityObject 모델 필드 (기존)

```python
class ActivityObject(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4)
    project = models.ForeignKey(Project, on_delete=models.CASCADE)
    activity = models.ForeignKey(Activity, on_delete=models.CASCADE)
    cost_item = models.ForeignKey(CostItem, on_delete=models.CASCADE)

    quantity = models.DecimalField(max_digits=20, decimal_places=6, null=True, blank=True)
    actual_duration = models.DecimalField(max_digits=20, decimal_places=6, null=True, blank=True)

    # 수동 입력 관련 필드
    is_manual = models.BooleanField(default=False)
    manual_formula = models.TextField(null=True, blank=True)
    quantity_expression = models.JSONField(null=True, blank=True)

    # 일정 필드
    start_date = models.DateField(null=True, blank=True)
    end_date = models.DateField(null=True, blank=True)
    actual_start_date = models.DateField(null=True, blank=True)
    actual_end_date = models.DateField(null=True, blank=True)

    is_active = models.BooleanField(default=True)
    created_at = models.DateTimeField(auto_now_add=True)
```

### 필드 설명

**is_manual** (Boolean):
- `False`: 자동 계산 모드 (Case 1)
- `True`: 수동 입력 모드 (Case 2 or Case 3)

**manual_formula** (TextField):
- `null`: 직접 입력 모드 (Case 2)
- `"{CI.quantity} * 2.5"`: 산식 입력 모드 (Case 3)

**quantity_expression** (JSONField):
- 직접 입력 모드: `{"mode": "direct", "value": 125.5}`
- 산식 입력 모드: `{"mode": "formula", "formula": "{CI.quantity} * 2.5"}`

## API 엔드포인트

### ActivityObject API

**URL**: `/connections/api/activity-objects/<project_id>/<ao_id>/`

**Method**: PUT

**Request Body**:
```json
{
    "quantity": 125.5,
    "is_manual": true,
    "manual_formula": "{CI.quantity} * 2.5",
    "quantity_expression": {
        "mode": "formula",
        "formula": "{CI.quantity} * 2.5"
    }
}
```

**Response**:
```json
{
    "message": "액티비티 객체가 업데이트되었습니다."
}
```

## 사용 시나리오

### 시나리오 1: 직접 수량 입력

**사용자 동작**:
1. 액티비티 객체 탭 진입
2. 수정할 액티비티 객체들을 체크박스로 선택
3. "수동 수량입력" 버튼 클릭
4. 모달에서 "직접 입력 (숫자)" 라디오 버튼 선택 (기본값)
5. 수량 값 입력 (예: `150`)
6. "적용" 버튼 클릭

**결과**:
- 선택된 모든 액티비티 객체의 `quantity` 값이 `150`으로 업데이트
- `is_manual = true`, `manual_formula = null`
- `quantity_expression = {"mode": "direct", "value": 150}`
- 향후 "자동 수량계산" 실행 시 이 값은 유지됨 (건너뜀)

### 시나리오 2: 산식으로 수량 계산

**사용자 동작**:
1. 액티비티 객체 탭 진입
2. 수정할 액티비티 객체들을 체크박스로 선택
3. "수동 수량입력" 버튼 클릭
4. 모달에서 "산식 입력" 라디오 버튼 선택
5. 산식 입력란에 산식 입력: `{CI.quantity} * {Activity.duration_per_unit} * 1.2`
   - 또는 드롭다운에서 속성 선택 후 "삽입" 버튼 클릭
6. "적용" 버튼 클릭

**결과**:
- 각 액티비티 객체별로 산식이 평가되어 `quantity` 값 업데이트
- `is_manual = true`, `manual_formula = "{CI.quantity} * {Activity.duration_per_unit} * 1.2"`
- `quantity_expression = {"mode": "formula", "formula": "..."}`
- 향후 "자동 수량계산" 실행 시 산식이 재평가됨 (데이터 변경 시 자동 반영)

### 시나리오 3: 자동 수량계산 실행

**사용자 동작**:
1. 액티비티 객체 탭 진입
2. "자동 수량계산" 버튼 클릭
3. 확인 대화상자에서 "확인" 클릭

**시스템 동작**:

**Case 1 - 자동 계산 객체** (is_manual=false):
```
AO.quantity = Activity.duration_per_unit * CI.quantity
예: 0.5 * 250 = 125
→ 업데이트 수행
```

**Case 2 - 직접 입력 객체** (is_manual=true, manual_formula=null):
```
→ 건너뜀 (사용자가 입력한 150 유지)
```

**Case 3 - 산식 입력 객체** (is_manual=true, manual_formula 존재):
```
Context = {
    'CI.quantity': 250,
    'Activity.duration_per_unit': 0.5,
    ...
}
Formula = "{CI.quantity} * {Activity.duration_per_unit} * 1.2"
→ 250 * 0.5 * 1.2 = 150
→ 업데이트 수행
```

**결과 메시지**:
```
자동 수량계산 완료: 45개 업데이트, 5개 건너뜀
```

## 산식 평가 시스템

### evaluateQuantityFormula() 함수

**위치**: `connections/static/connections/cost_item_manager.js` (재사용)

**역할**: 템플릿 표현식을 컨텍스트 값으로 치환하고 계산

**예시**:
```javascript
const context = {
    'CI.quantity': 250,
    'Activity.duration_per_unit': 0.5,
    'QM.volume': 100
};

const formula = "{CI.quantity} * {Activity.duration_per_unit}";
const result = evaluateQuantityFormula(formula, context);
// result = 125
```

### 지원되는 속성

#### ActivityObject (AO)
- `{AO.id}` - 고유 ID
- `{AO.quantity}` - 수량
- `{AO.actual_duration}` - 실제 작업기간

#### Activity
- `{Activity.code}` - 액티비티 코드
- `{Activity.name}` - 액티비티 이름
- `{Activity.duration_per_unit}` - 단위당 작업기간
- `{Activity.unit}` - 단위

#### CostItem (CI)
- `{CI.id}` - 코스트아이템 ID
- `{CI.quantity}` - 코스트아이템 수량
- `{CI.group_name}` - 그룹명

#### CostCode
- `{CostCode.code}` - 코스트 코드
- `{CostCode.name}` - 코스트 이름
- `{CostCode.detail_code}` - 세부 코드

#### QuantityMember (QM)
- `{QM.volume}` - 체적
- `{QM.area}` - 면적
- `{QM.length}` - 길이
- `{QM.properties.속성명}` - 커스텀 속성

#### MemberMark (MM)
- `{MM.mark}` - 부재 마크

#### BIM Raw Data
- `{BIM.Category}` - 카테고리
- `{BIM.Family}` - 패밀리
- `{BIM.Type}` - 타입
- `{BIM.Parameters.속성명}` - 인스턴스 파라미터
- `{BIM.TypeParameters.속성명}` - 타입 파라미터

### 산식 예시

```javascript
// 단순 곱셈
"{CI.quantity} * 2.5"

// 복합 계산
"{CI.quantity} * {Activity.duration_per_unit} * 1.2"

// BIM 데이터 활용
"{QM.volume} * {BIM.Parameters.밀도}"

// 면적 기반 계산
"{QM.area} * 0.05"

// 조건부 계산 (JavaScript 표현식)
"{CI.quantity} > 100 ? {CI.quantity} * 1.1 : {CI.quantity}"
```

## 트러블슈팅

### 문제 1: 서버 NameError

**증상**:
- 수동 수량입력 적용 시 400 Bad Request 오류
- 서버 로그: `NameError: name 'ActivityObject' is not defined`

**원인**:
- 서버가 이전 버전의 코드를 캐싱
- 실제로는 `ActivityObject`가 `views.py` line 63에 import되어 있음
- 에러 line number (5997)와 실제 함수 위치 (6078)가 불일치

**해결**:
```bash
# 기존 서버 프로세스 종료
kill $(lsof -ti:8000)

# 새 서버 시작
.mddoyun/bin/python manage.py runserver
```

**예방**:
- 코드 수정 후 Django의 auto-reload가 제대로 작동하는지 확인
- 복잡한 변경 시 수동으로 서버 재시작

### 문제 2: Context 속성 누락

**증상**:
- 산식 평가 시 `undefined` 값 발생
- 예: `{Activity.duration_per_unit}`가 `undefined`

**원인**:
- `buildActivityObjectContext()` 함수에서 중첩된 객체 참조 누락
- 예: `ao.activity`가 null이거나 로드되지 않음

**해결**:
```javascript
// Context builder에 방어 코드 추가
if (ao.activity) {
    context['Activity.duration_per_unit'] = ao.activity.duration_per_unit || 0;
} else {
    context['Activity.duration_per_unit'] = 0; // 기본값
}
```

**디버깅**:
```javascript
console.log('[DEBUG][buildActivityObjectContext] Built context:', context);
// → 어떤 속성이 누락되었는지 확인
```

## 테스트 체크리스트

### 수동 수량입력 테스트

- [ ] 직접 입력 모드로 단일 객체 업데이트
- [ ] 직접 입력 모드로 여러 객체 일괄 업데이트
- [ ] 산식 입력 모드로 단일 객체 업데이트
- [ ] 산식 입력 모드로 여러 객체 일괄 업데이트
- [ ] 속성 드롭다운에서 속성 선택 후 삽입
- [ ] 잘못된 산식 입력 시 에러 처리
- [ ] 빈 값 입력 시 에러 처리

### 자동 수량계산 테스트

- [ ] 자동 계산 객체들 재계산 확인
- [ ] 직접 입력 객체들 건너뜀 확인
- [ ] 산식 입력 객체들 재평가 확인
- [ ] 결과 메시지 정확성 확인
- [ ] 테이블 자동 새로고침 확인

### Context Builder 테스트

- [ ] ActivityObject 속성 접근
- [ ] Activity 속성 접근
- [ ] CostItem 속성 접근
- [ ] QuantityMember 속성 접근
- [ ] MemberMark 속성 접근
- [ ] BIM Raw Data 속성 접근
- [ ] 중첩된 속성 접근 (예: QM.properties.*)

### 산식 평가 테스트

- [ ] 단순 산술 연산 (`{A} + {B}`)
- [ ] 복합 연산 (`{A} * {B} / {C}`)
- [ ] BIM 속성 참조
- [ ] 조건부 표현식 (삼항 연산자)

## 영향 범위

### 수정된 파일

1. **connections/templates/revit_control.html** (Line 2747-2758)
   - 자동 수량계산 버튼 추가
   - 수동 수량입력 버튼 추가

2. **connections/static/connections/activity_object_manager.js**
   - Line 83-91: 이벤트 리스너 등록
   - Line 1396-1685: `showManualAoQuantityInputModal()` 구현
   - Line 2027-2113: `recalculateAllAoQuantities()` 구현
   - Line 2118-2213: `buildActivityObjectContext()` 구현

### 영향받는 기능

- ✅ 액티비티 객체 생성 (기존 자동 계산 유지)
- ✅ 액티비티 객체 편집 (새로운 수동 입력 모드 추가)
- ✅ 액티비티 객체 삭제 (영향 없음)
- ✅ 산출항목 수량 변경 시 액티비티 객체 재계산

### 호환성

- 기존 액티비티 객체 데이터와 호환됨 (is_manual=false가 기본값)
- 코스트아이템의 수동 수량입력과 동일한 패턴 사용
- 산식 평가 시스템 공유 (evaluateQuantityFormula)

## 향후 개선 사항

### 제안 1: 일괄 산식 적용

**현재**:
- 여러 객체 선택 시 같은 산식이 모두에게 적용됨

**개선**:
- 객체별로 다른 산식을 한 번에 입력할 수 있는 테이블 편집 모드
- 예: 인라인 편집으로 각 행마다 산식 입력

### 제안 2: 산식 템플릿

**현재**:
- 사용자가 매번 산식을 직접 입력

**개선**:
- 자주 사용하는 산식을 템플릿으로 저장
- 드롭다운에서 템플릿 선택 후 적용
- 예: "단위당 작업기간 * 수량 * 계수"

### 제안 3: 산식 검증 및 미리보기

**현재**:
- 적용 후에만 결과 확인 가능

**개선**:
- 산식 입력 중 실시간 검증
- 미리보기 테이블에 계산 결과 표시
- 오류 발생 가능한 산식 경고

### 제안 4: 조건부 자동 재계산

**현재**:
- 사용자가 "자동 수량계산" 버튼 수동 클릭

**개선**:
- 산출항목 수량 변경 시 자동으로 액티비티 객체 재계산
- 설정에서 자동/수동 재계산 모드 선택 가능
- 변경 사항 추적 및 알림

## 참고 사항

### 유사 기능

이 구현은 `cost_item_manager.js`의 수동 수량입력 기능과 동일한 패턴을 따릅니다:
- 모달 UI 구조 유사
- `quantity_expression` JSON 필드 구조 동일
- `evaluateQuantityFormula()` 함수 공유

### 데이터 일관성

- **Soft Delete 패턴**: `is_active=false`로 삭제 처리
- **UUID Primary Keys**: 모든 객체에 UUID 사용
- **DecimalField**: 정확한 수량 계산을 위해 Decimal 사용 (max_digits=20, decimal_places=6)

### 성능 고려사항

- 자동 수량계산은 순차 처리 (for loop)
- 대량의 액티비티 객체(1000개 이상) 시 시간 소요 가능
- 향후 개선: 배치 업데이트 API로 변경 검토

### 디버그 로그

모든 주요 함수에 디버그 로그 추가:
- `[DEBUG][showManualAoQuantityInputModal]`
- `[DEBUG][recalculateAllAoQuantities]`
- `[DEBUG][buildActivityObjectContext]`

필요 시 콘솔에서 로그 확인하여 문제 진단 가능

## 관련 문서

- 이전 작업: `54_2025-11-04_액티비티객체_삭제_UI_업데이트_수정.md`
- 이전 작업: `55_2025-11-04_코스트아이템_액티비티별뷰_그룹핑_수정.md`
- 관련 기능: 코스트아이템 수동 수량입력 (`cost_item_manager.js`)
- 관련 기능: 액티비티 객체 관리 전반

## 커밋 정보

커밋 전 체크리스트:
- [x] HTML 버튼 추가
- [x] 수동 수량입력 모달 구현
- [x] Context builder 구현
- [x] 자동 수량계산 구현
- [x] 이벤트 리스너 등록
- [x] 서버 재시작 및 테스트
- [ ] 사용자 테스트 확인 (대기 중)

다음 단계: 사용자가 기능을 테스트하고 피드백 제공
