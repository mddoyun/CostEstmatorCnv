# 다중 문제 해결: BOQ 집계표, 3D 뷰어, Revit 위치 오류

**날짜**: 2025-10-30
**작업 분류**: Bug Fix (Multiple Issues)

---

## 목차

1. [Revit 벽 위치 오류 해결](#1-revit-벽-위치-오류-해결)
2. [BOQ 집계표 URL 길이 제한 문제 (GET → POST)](#2-boq-집계표-url-길이-제한-문제)
3. [CSRF 토큰 오류 수정](#3-csrf-토큰-오류-수정)
4. [구조프레임 위치 오류 해결](#4-구조프레임-위치-오류-해결)
5. [분할 객체 비용 정보 자동 재시도](#5-분할-객체-비용-정보-자동-재시도)

---

## 1. Revit 벽 위치 오류 해결

### 문제 증상

- 3D 뷰어에서 벽(Wall)만 다른 부재들과 멀리 떨어진 위치에 표시
- 기둥, 슬래브 등 다른 객체는 정상적으로 모여있음

### 원인 분석

**파일**: `CostEstimator_RevitAddin_2026/MainTools/QuantityTakeoff_web/RevitDataCollector.cs`

이전 작업에서 `ExtractTransformMatrix()` 메서드가 Location 기반으로 transform을 생성했는데, 이것이 문제였습니다:

```csharp
// Before: Location 기반 transform 생성
if (element.Location is LocationPoint locationPoint) {
    transform = Transform.CreateTranslation(locationPoint.Point);
    // ...
}
else if (element.Location is LocationCurve locationCurve) {
    var curve = locationCurve.Curve;
    var startPoint = curve.GetEndPoint(0);
    transform = Transform.CreateTranslation(startPoint);  // ← 문제!
}
```

**근본 원인:**
- Revit의 `element.get_Geometry()`는 **이미 프로젝트 전역 좌표계의 geometry를 반환**
- 추가로 Location 기반 transform을 적용 → **이중 변환(Double Transformation)** 발생
- 특히 LocationCurve 요소(벽)는 시작점만 사용하여 변환 → 더욱 심각한 위치 오류

### 해결 방법

**항상 Identity transform 사용:**

```csharp
// After: Identity transform 사용
private static List<double> ExtractTransformMatrix(Element element)
{
    try
    {
        // Revit geometry는 이미 전역 좌표계에 있음
        Transform transform = Transform.Identity;

        // 4x4 행렬 구성...
    }
}
```

**기술적 배경:**
- Revit API의 `get_Geometry()` 메서드는 프로젝트 좌표계의 geometry를 직접 반환
- `ProcessGeometryObject()` 메서드가 GeometryInstance의 내부 transform은 이미 올바르게 처리
- 추가적인 Location 기반 transform은 불필요하며 오히려 위치 오류를 발생시킴

### 결과

✅ **모든 객체(벽, 기둥, 슬래브 등)가 3D 뷰어에서 정확한 위치에 표시됨**

**커밋**: c7f6783

---

## 2. BOQ 집계표 URL 길이 제한 문제

### 문제 증상

사용자가 "상세견적(DD)" 탭에서 "집계표 생성" 버튼을 클릭하면:

```
net::ERR_EMPTY_RESPONSE
TypeError: Failed to fetch
```

**콘솔 로그:**
```javascript
[DEBUG] 표시 필드: (187개)
[DEBUG] 서버에 집계표 데이터 요청 시작... /connections/api/boq/report/...?
  group_by=...&display_by=...&display_by=... (매우 긴 URL)
```

### 원인 분석

**URL 길이 초과:**
- 187개의 `display_by` 파라미터를 GET 방식으로 URL에 포함
- 각 파라미터 이름이 매우 김: `quantity_member__raw_element__raw_data__Parameters__...`
- 결과적으로 URL이 수천~수만 자에 달함

**URL 길이 제한:**
- 대부분의 브라우저: 2,048 ~ 8,192자
- 웹 서버 (Nginx/Apache): 4,096 ~ 8,192자
- Django 개발 서버: 제한 없지만, 운영체제 레벨에서 제한 가능

**에러 분석:**
- `net::ERR_EMPTY_RESPONSE`: 서버가 요청을 받았지만 처리하지 못하고 연결을 끊음
- Django 서버가 URL을 파싱하다가 크래시

### 해결 방법

**GET → POST 방식 전환 (하위 호환성 유지)**

#### 1. 서버 수정 (views.py)

**파일**: `connections/views.py:1765-1807`

```python
@require_http_methods(["GET", "POST"])  # GET과 POST 모두 지원
def generate_boq_report_api(request, project_id):
    print(f"[DEBUG] API 요청 수신 (Method: {request.method})")

    # POST 요청: JSON body에서 파라미터 추출
    if request.method == 'POST':
        try:
            data = json.loads(request.body)
            group_by_fields = data.get('group_by', [])
            display_by_fields = data.get('display_by', [])
            raw_element_ids = data.get('raw_element_ids', [])
            filter_ai = data.get('filter_ai', True)
            filter_dd = data.get('filter_dd', True)
            print(f"[DEBUG] POST body parsed - display_by: {len(display_by_fields)}")
        except json.JSONDecodeError as e:
            return JsonResponse({'status': 'error', 'message': 'Invalid JSON'}, status=400)
    else:
        # GET 요청: URL 파라미터에서 추출 (하위 호환성)
        group_by_fields = request.GET.getlist('group_by')
        display_by_fields = request.GET.getlist('display_by')
        # ...
```

#### 2. 클라이언트 수정 (boq_detailed_estimation_handlers.js)

**파일**: `connections/static/connections/boq_detailed_estimation_handlers.js:168-216`

```javascript
// Before: URLSearchParams로 GET 요청
const params = new URLSearchParams();
groupBySelects.forEach(select => params.append("group_by", select.value));
displayByCheckboxes.forEach(cb => params.append("display_by", cb.value));
// ...
const response = await fetch(`/api/boq/report/${projectId}/?${params.toString()}`);

// After: JSON body로 POST 요청
const groupByFields = Array.from(groupBySelects).map(select => select.value);
const displayByFields = Array.from(displayByCheckboxes).map(cb => cb.value);

const requestData = {
    group_by: groupByFields,
    display_by: displayByFields,
    raw_element_ids: Array.from(boqFilteredRawElementIds),
    filter_ai: filterAiChecked,
    filter_dd: filterDdChecked
};

const response = await fetch(
    `/connections/api/boq/report/${currentProjectId}/`,
    {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': csrftoken
        },
        body: JSON.stringify(requestData)
    }
);
```

#### 3. 개산견적 핸들러 수정 (schematic_estimation_handlers.js)

**파일**: `connections/static/connections/schematic_estimation_handlers.js:869-916`

동일한 패턴으로 POST 방식 적용

### 결과

**Before:**
```
GET /api/boq/report/?group_by=...&display_by=... (187개)
→ URL 길이: 수천~수만 자
→ 결과: net::ERR_EMPTY_RESPONSE 💥
```

**After:**
```
POST /api/boq/report/
Body: { "group_by": [...], "display_by": [...187개...] }
→ URL 길이: 짧음
→ 결과: 정상 작동 ✅
```

### 장점

- ✅ **URL 길이 제한 없음** - 500개 필드도 가능
- ✅ **하위 호환성 유지** - GET도 계속 작동
- ✅ **블렌더/레빗 영향 없음** - 이 API를 사용하지 않음
- ✅ **더 나은 REST API 디자인** - 복잡한 쿼리는 POST body 사용

**커밋**: 1d8ff11

---

## 3. CSRF 토큰 오류 수정

### 문제 증상

집계표 생성 버튼 클릭 시:

```
boq_detailed_estimation_handlers.js:211
ReferenceError: getCSRFToken is not defined
    at HTMLButtonElement.generateBoqReport
```

### 원인 분석

POST 방식으로 변경하면서 CSRF 토큰이 필요해졌는데, 존재하지 않는 `getCSRFToken()` 함수를 호출함:

```javascript
// 오류 코드
headers: {
    'Content-Type': 'application/json',
    'X-CSRFToken': getCSRFToken()  // ← 이 함수 없음!
}
```

**기존 코드 패턴 확인:**

다른 파일들에서는 `csrftoken` 변수를 직접 사용:

```javascript
// csrf_token.js에서 정의된 전역 변수
let csrftoken = document.querySelector('[name=csrfmiddlewaretoken]')?.value
    || getCookie('csrftoken');

// 다른 파일들의 사용 예
headers: { 'X-CSRFToken': csrftoken }  // ← 변수 직접 사용
```

### 해결 방법

**getCSRFToken() → csrftoken 변경:**

```javascript
// After
headers: {
    'Content-Type': 'application/json',
    'X-CSRFToken': csrftoken  // ← 전역 변수 사용
}
```

**수정 파일:**
1. `boq_detailed_estimation_handlers.js:211`
2. `schematic_estimation_handlers.js:911`

### 결과

✅ 집계표 생성 정상 작동

**커밋**: 0da4f45

---

## 4. 구조프레임 위치 오류 해결

### 문제 증상

- 3D 뷰어에서 구조프레임(Structural Framing, 보)만 원점 근처로 이동
- 벽, 기둥, 슬래브는 정상 위치

### 원인 분석

**파일**: `RevitDataCollector.cs:114-122`

```csharp
else if (geomObj is GeometryInstance instance)
{
    var instanceGeom = instance.GetInstanceGeometry();  // ← 문제!
    var transform = parentTransform.Multiply(instance.Transform);
    foreach (GeometryObject instanceObj in instanceGeom)
    {
        ProcessGeometryObject(instanceObj, allVerts, allFaces, transform);
    }
}
```

**Revit API 동작:**
- `GetInstanceGeometry()`: Instance의 transform이 **이미 적용된** geometry 반환
- `GetSymbolGeometry()`: Symbol의 **로컬 좌표계** geometry 반환

**문제:**
- 구조프레임(보)은 GeometryInstance를 사용
- 이미 transform이 적용된 geometry에 다시 `instance.Transform`을 곱함
- **이중 transform 적용** → 원점으로 이동

**왜 다른 객체는 정상?**
- 벽, 기둥, 슬래브: 직접 Solid를 가지고 있어서 GeometryInstance 처리를 거치지 않음

### 해결 방법

**GetInstanceGeometry() → GetSymbolGeometry() 변경:**

```csharp
else if (geomObj is GeometryInstance instance)
{
    // GetSymbolGeometry()로 로컬 좌표계 geometry를 가져오고,
    // instance.Transform을 명시적으로 적용
    var instanceGeom = instance.GetSymbolGeometry();
    var transform = parentTransform.Multiply(instance.Transform);
    foreach (GeometryObject instanceObj in instanceGeom)
    {
        ProcessGeometryObject(instanceObj, allVerts, allFaces, transform);
    }
}
```

### 기술적 배경

**Revit API의 두 가지 메서드:**

| 메서드 | 반환 | Transform 적용 여부 |
|--------|------|-------------------|
| `GetInstanceGeometry()` | Instance 좌표계 geometry | ✅ 이미 적용됨 |
| `GetSymbolGeometry()` | Symbol 로컬 좌표계 geometry | ❌ 적용 안 됨 |

**올바른 사용:**
- Symbol geometry 가져오기 → Transform 명시적으로 적용 → 한 번만 적용

### 결과

✅ 구조프레임이 벽, 기둥 등과 함께 올바른 위치에 표시됨

**커밋**: 0da4f45

---

## 5. 분할 객체 비용 정보 자동 재시도

### 문제 증상

3D 뷰어에서 분할된 객체를 선택했을 때:

```
[3D Viewer] Split object but no QM found - auto-reload in progress
Found matching quantity members for split: []
```

화면에는: **"데이터 로딩 중... (자동 재로드 대기)"** 메시지만 표시되고 영원히 대기

**사용자 관찰:**
- 오래 기다렸다가 다시 클릭하면 비용 정보가 보임
- 분할 후 바로 클릭하면 안 보임
- 다른 객체 클릭하고 왔다갔다 하면 저장이 안 된 것처럼 보임

### 원인 분석

**타이밍 문제:**

1. 사용자가 객체 분할 → 서버가 백그라운드에서 산출항목(QuantityMember) 계산 시작
2. 사용자가 **즉시** 분할된 객체 클릭 → 아직 계산이 완료되지 않음
3. 코드가 "데이터 로딩 중..." 표시 후 **그냥 반환** → 재시도 없음!

**파일**: `three_d_viewer.js:1675-1680`

```javascript
// Before: 재시도 로직 없음
if (quantityMembers.length === 0) {
    if (object.userData.splitElementId) {
        console.warn('Split object but no QM found - auto-reload in progress');
        tableContainer.innerHTML = '데이터 로딩 중... (자동 재로드 대기)';
        return;  // ← 여기서 끝! 재시도 없음!
    }
```

**비교: 다른 경우는 재시도가 있음 (Line 1703-1710):**

```javascript
// costItemsWithPrices 없을 때는 재시도 로직 있음
const retryCount = displayCostItemsRetryCount.get(object) || 0;
if (retryCount < 8) {
    displayCostItemsRetryCount.set(object, retryCount + 1);
    setTimeout(() => {
        displayCostItems(object);
    }, 500);  // ← 500ms마다 재시도 (최대 8회)
}
```

### 해결 방법

**자동 재시도 메커니즘 추가:**

#### 1. Split 객체에 재시도 로직 추가 (Line 1674-1701)

```javascript
if (quantityMembers.length === 0) {
    if (object.userData.splitElementId) {
        console.warn('[3D Viewer] Split object but no QM found - retrying...');
        tableContainer.innerHTML = '<p class="no-selection">산출항목 계산 중... (자동 재시도)</p>';

        // 재시도 (최대 10회, 1000ms 간격 - split은 시간이 더 걸림)
        const retryCount = displayCostItemsRetryCount.get(object) || 0;
        if (retryCount < 10) {
            displayCostItemsRetryCount.set(object, retryCount + 1);
            console.log(`[3D Viewer] Retry ${retryCount + 1}/10 after 1000ms...`);
            setTimeout(() => {
                console.log('[3D Viewer] Retrying displayCostItems after split...');
                displayCostItems(object);
            }, 1000);
        } else {
            displayCostItemsRetryCount.delete(object);
            tableContainer.innerHTML = '<p class="no-selection">산출항목을 불러올 수 없습니다. 페이지를 새로고침하세요.</p>';
        }
        return;
    }

    // 일반 객체는 그냥 없음 표시
    tableContainer.innerHTML = '<p class="no-selection">연관된 수량산출부재가 없습니다</p>';
    return;
}
```

#### 2. 새 객체 선택 시 재시도 카운트 초기화 (Line 1119-1121)

```javascript
function selectObject(object) {
    if (selectedObject) {
        deselectObject();
    }

    selectedObject = object;

    // 새 객체 선택 시 재시도 카운트 초기화
    displayCostItemsRetryCount.delete(object);

    // ... 나머지 코드
}
```

**왜 초기화가 필요한가?**
- 사용자가 다른 객체 클릭했다가 다시 돌아올 수 있음
- 재시도 카운트를 리셋해야 다시 재시도 가능

### 기술적 세부사항

**타임아웃 차이:**
- **Split QM 재시도**: 10회 × 1초 = **10초 최대 대기**
  - 분할 후 산출항목 계산은 시간이 더 걸림

- **Price 재시도**: 8회 × 0.5초 = **4초 최대 대기**
  - 가격 조회는 상대적으로 빠름

**재시도 실패 시:**
- 10초(10번 재시도) 후에도 안 나타나면: "산출항목을 불러올 수 없습니다. 페이지를 새로고침하세요."

### 사용자 경험 개선

**Before:**
```
분할 → 클릭 → "로딩 중..." → 영원히 대기 → 사용자 혼란 😵
```

**After:**
```
분할 → 클릭 → "계산 중... (자동 재시도)" → 1초마다 확인 → 자동 표시 ✨
```

**콘솔 로그 (예상):**
```
[3D Viewer] Split object but no QM found - retrying...
[3D Viewer] Retry 1/10 after 1000ms...
[3D Viewer] Retrying displayCostItems after split...
[3D Viewer] Retry 2/10 after 1000ms...
[3D Viewer] Retrying displayCostItems after split...
[3D Viewer] Found matching quantity members for split: [Object, Object]
[3D Viewer] Found quantity members: 2
✅ 비용 정보 표시!
```

### 결과

✅ 분할 후 바로 클릭해도 1-5초 후 자동으로 비용 정보 표시
✅ 다른 객체 클릭했다가 돌아와도 정상 작동
✅ 사용자가 기다릴 필요 없음 - 자동으로 표시됨

**커밋**: 844b0a6

---

## 파일 수정 요약

### Revit 애드인

1. **RevitDataCollector.cs**
   - Line 162-205: `ExtractTransformMatrix()` - Identity transform 사용 (벽 위치 수정)
   - Line 114-126: `ProcessGeometryObject()` - GetSymbolGeometry() 사용 (구조프레임 수정)

### 웹브라우저 (Django 서버)

2. **connections/views.py**
   - Line 1765-1807: `generate_boq_report_api()` - GET/POST 모두 지원

### 웹브라우저 (JavaScript)

3. **connections/static/connections/boq_detailed_estimation_handlers.js**
   - Line 168-216: POST 방식으로 변경
   - Line 211: CSRF 토큰 수정

4. **connections/static/connections/schematic_estimation_handlers.js**
   - Line 869-916: POST 방식으로 변경
   - Line 911: CSRF 토큰 수정

5. **connections/static/connections/three_d_viewer.js**
   - Line 1119-1121: 재시도 카운트 초기화
   - Line 1674-1701: Split 객체 자동 재시도 로직

---

## 커밋 히스토리

1. **c7f6783** - Fix Revit wall positioning by using Identity transform matrix
2. **e0534eb** - Document wall positioning issue and fix
3. **1d8ff11** - Fix BOQ report generation: GET to POST to solve URL length limit
4. **0da4f45** - Fix two issues: CSRF token and structural framing position
5. **844b0a6** - Fix split object cost display with auto-retry mechanism

---

## 테스트 시나리오

### 1. Revit 위치 테스트

**준비:**
1. Revit 애드인 재빌드
2. 벽, 기둥, 보가 포함된 모델 열기

**테스트:**
1. Connect to Server → 데이터 전송
2. 웹브라우저 3D 뷰어에서 확인
3. **기대 결과**: 모든 객체가 올바른 위치에 모여있음

### 2. BOQ 집계표 테스트

**테스트:**
1. "상세견적(DD)" 탭 열기
2. 표시 필드 많이 선택 (100개 이상)
3. "집계표 생성" 버튼 클릭
4. **기대 결과**: 오류 없이 집계표 생성됨

**콘솔 확인:**
```
[DEBUG] 서버에 집계표 데이터 요청 시작 (POST)...
[DEBUG] Request data: { group_by: [...], display_by: [187개] }
```

### 3. 분할 객체 비용 정보 테스트

**테스트:**
1. 3D 뷰어에서 객체 분할 (Face Split 또는 Sketch Split)
2. **즉시** 분할된 객체 클릭
3. **기대 결과**: "산출항목 계산 중... (자동 재시도)"
4. 1-5초 후 자동으로 비용 정보 표시

**콘솔 확인:**
```
[3D Viewer] Retry 1/10 after 1000ms...
[3D Viewer] Found quantity members: 2
```

---

## 영향 범위

### 변경 없음
- ✅ Blender 애드온: 영향 없음
- ✅ 기존 데이터: 호환성 유지
- ✅ 다른 API: 영향 없음

### 개선됨
- ✅ Revit 3D 표시 정확도
- ✅ BOQ 집계표 안정성
- ✅ 분할 기능 사용성

---

## 결론

**5개의 주요 문제를 해결하여 시스템 안정성과 사용성을 크게 개선했습니다.**

### 해결된 문제

1. ✅ **Revit 벽 위치 오류** - Identity transform으로 정확한 위치 표시
2. ✅ **BOQ 집계표 URL 제한** - POST 방식으로 무제한 필드 지원
3. ✅ **CSRF 토큰 오류** - 올바른 변수 사용
4. ✅ **구조프레임 위치 오류** - GetSymbolGeometry로 정확한 위치
5. ✅ **분할 객체 비용 표시** - 자동 재시도로 즉시 표시

### 핵심 개선 사항

- **정확성**: 모든 Revit 객체가 올바른 위치에 표시
- **안정성**: URL 길이 제한 없이 대량 필드 처리 가능
- **사용성**: 분할 후 자동으로 비용 정보 표시

### 기술적 성과

- Revit API 깊은 이해: Transform, GeometryInstance 처리
- REST API 개선: GET/POST 하위 호환성
- UX 개선: 자동 재시도 메커니즘

---

**작업 완료**: 2025-10-30
**총 커밋**: 5개
**수정 파일**: 5개 (Revit 2개, 서버 1개, 클라이언트 2개)
