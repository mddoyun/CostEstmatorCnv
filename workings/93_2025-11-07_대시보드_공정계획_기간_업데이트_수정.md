# 2025-11-07: 홈 탭 대시보드 공정계획 기간 업데이트 수정

## 작업 개요
홈 탭 대시보드의 "공정계획" 카드에서 총 공사기간이 "데이터 없음"으로 표시되는 문제를 해결했습니다.

## 문제 상황

### 증상
- 홈 탭의 공정계획 카드에 프로젝트 기간이 표시되지 않음
- "데이터 없음" 메시지만 표시됨
- 공정계획 탭에서는 정상적으로 프로젝트 기간이 계산되어 표시됨

### 원인 분석

#### 1. 전역 변수 노출 누락
**문제**: `gantt_chart_handlers.js`에서 `ganttMinDate`, `ganttMaxDate`를 로컬 변수로만 저장
```javascript
// 기존 코드 (line 669-670)
ganttMinDate = minDate;
ganttMaxDate = maxDate;
// window.ganttMinDate, window.ganttMaxDate 노출 안됨
```

**영향**: `home_tab_handlers.js`의 `calculateScheduleDatesFromGantt()` 함수가 `window.ganttMinDate`와 `window.ganttMaxDate`를 참조하지만 값이 없음

#### 2. 대시보드 업데이트 트리거 누락
**문제**: 간트차트 로드 후 대시보드 업데이트 함수 호출 없음

**영향**: 사용자가 공정계획 탭에서 간트차트를 로드해도 홈 탭의 대시보드는 업데이트되지 않음

## 해결 방법

### 1. 전역 변수 노출 추가

**파일**: `connections/static/connections/gantt_chart_handlers.js`
**위치**: Line 668-672

```javascript
// 전역 변수에 저장 (대시보드에서도 접근 가능하도록 window에 노출)
ganttMinDate = minDate;
ganttMaxDate = maxDate;
window.ganttMinDate = minDate;
window.ganttMaxDate = maxDate;
```

**효과**: `calculateScheduleDatesFromGantt()` 함수가 간트차트에서 계산된 날짜를 참조 가능

### 2. 대시보드 업데이트 트리거 추가

**파일**: `connections/static/connections/gantt_chart_handlers.js`
**위치**: Line 244-248 (loadAndRenderGanttChart 함수 내)

```javascript
// 간트차트 렌더링
renderGanttChart(ganttData);

// 간트차트 로드 후 대시보드 업데이트 (홈 탭의 공정계획 카드 업데이트)
if (typeof window.loadHomeDashboardData === 'function') {
    console.log('[Gantt Chart] Triggering dashboard update after gantt load');
    window.loadHomeDashboardData(currentProjectId);
}
```

**효과**: 간트차트 로드 완료 시 자동으로 대시보드 업데이트

## 데이터 흐름

### 수정 전
```
1. 공정계획 탭 로드
   ↓
2. loadAndRenderGanttChart()
   ↓
3. ganttMinDate, ganttMaxDate 계산 (로컬 변수만)
   ↓
4. 간트차트 렌더링
   ↓
5. (끝) - 대시보드 업데이트 없음
```

### 수정 후
```
1. 공정계획 탭 로드
   ↓
2. loadAndRenderGanttChart()
   ↓
3. ganttMinDate, ganttMaxDate 계산
   ├─ 로컬 변수에 저장
   └─ window.ganttMinDate, window.ganttMaxDate에도 노출
   ↓
4. 간트차트 렌더링
   ↓
5. loadHomeDashboardData(projectId) 호출
   ↓
6. calculateScheduleDatesFromGantt()
   ├─ window.ganttMinDate 확인 → 있음 ✓
   └─ window.ganttMaxDate 확인 → 있음 ✓
   ↓
7. updateDashboardUI(data)
   └─ 공정계획 카드 업데이트 완료
```

## 대시보드 계산 로직

`home_tab_handlers.js`의 `calculateScheduleDatesFromGantt()` 함수 (lines 633-728):

### 우선순위 1: 기존 간트차트 날짜 사용
```javascript
// 간트차트가 이미 렌더링된 경우
if (window.ganttMinDate && window.ganttMaxDate) {
    const totalDays = Math.ceil((window.ganttMaxDate - window.ganttMinDate) / (1000 * 60 * 60 * 24));
    return {
        start_date_formatted: window.ganttMinDate.toLocaleDateString('ko-KR'),
        end_date_formatted: window.ganttMaxDate.toLocaleDateString('ko-KR'),
        total_days: totalDays
    };
}
```

### 우선순위 2: ActivityObjects에서 직접 계산
```javascript
// 간트차트 미렌더링 시 loadedActivityObjects에서 계산
if (!window.loadedActivityObjects || window.loadedActivityObjects.length === 0) {
    return { start_date_formatted: null, end_date_formatted: null, total_days: 0 };
}

// ActivityObject의 actual_duration을 Activity별로 집계
const activityDurationMap = new Map();
window.loadedActivityObjects.forEach(ao => {
    const activityId = ao.activity.id;
    const duration = parseFloat(ao.actual_duration) || 0;
    const currentDuration = activityDurationMap.get(activityId) || 0;
    activityDurationMap.set(activityId, currentDuration + duration);
});

// 각 Activity의 start/end 날짜 계산 후 min/max 추출
const allDates = [];
activityDurationMap.forEach((totalDuration, activityId) => {
    const startDate = activity.manual_start_date ? new Date(activity.manual_start_date) : new Date();
    const endDate = new Date(startDate);
    endDate.setDate(endDate.getDate() + Math.ceil(totalDuration));
    allDates.push(startDate);
    allDates.push(endDate);
});

const minDate = new Date(Math.min(...allDates));
const maxDate = new Date(Math.max(...allDates));
const totalDays = Math.ceil((maxDate - minDate) / (1000 * 60 * 60 * 24));
```

## 영향받는 파일

### 1. `connections/static/connections/gantt_chart_handlers.js`

#### 변경 1: 전역 변수 노출 (lines 668-672)
- `window.ganttMinDate = minDate` 추가
- `window.ganttMaxDate = maxDate` 추가

#### 변경 2: 대시보드 업데이트 트리거 (lines 244-248)
- `loadAndRenderGanttChart()` 함수 끝에 대시보드 업데이트 호출 추가

### 2. `connections/static/connections/home_tab_handlers.js`
**변경 없음** - 기존 로직 그대로 사용

## 테스트 시나리오

### 시나리오 1: 간트차트 먼저 로드
1. 프로젝트 선택
2. 공정계획 탭 이동 → 간트차트 로드
3. 홈 탭 이동 → ✅ 공정계획 기간 표시됨
4. 기대 결과: "2025. 1. 1. ~ 2025. 12. 31. (365일)" 형식 표시

### 시나리오 2: 홈 탭에서 직접 계산
1. 프로젝트 선택 (간트차트 미로드)
2. 홈 탭 유지
3. `loadHomeDashboardData()` 자동 호출
4. ActivityObjects가 있으면 → ✅ 직접 계산하여 표시
5. ActivityObjects가 없으면 → "데이터 없음" 표시 (정상)

### 시나리오 3: 실시간 업데이트
1. 프로젝트 선택
2. 공정계획 탭에서 Activity 수정
3. 간트차트 자동 새로고침
4. 대시보드 자동 업데이트
5. 홈 탭 이동 → ✅ 최신 공정계획 기간 표시

## 기술적 세부사항

### 날짜 계산 일관성
간트차트와 대시보드 모두 동일한 계산 방식 사용:
```javascript
// Math.ceil만 사용, +1 안함 (2025-11-06 기준 수정사항)
const totalDays = Math.ceil((maxDate - minDate) / (1000 * 60 * 60 * 24));
```

### 전역 변수 관리
```javascript
// gantt_chart_handlers.js
let ganttMinDate = null;  // 모듈 레벨 변수
let ganttMaxDate = null;

// 계산 후
window.ganttMinDate = minDate;  // window에 노출
window.ganttMaxDate = maxDate;
```

### 함수 호출 체인
```
loadAndRenderGanttChart()
  → renderGanttChart()
  → window.loadHomeDashboardData()
    → calculateScheduleDatesFromGantt()
      → updateDashboardUI()
```

## 디버깅 로그

### 추가된 로그
```javascript
// gantt_chart_handlers.js (line 246)
console.log('[Gantt Chart] Triggering dashboard update after gantt load');

// home_tab_handlers.js (existing)
console.log('[Dashboard] Loading dashboard data for project:', projectId);
console.log('[Dashboard] Calculating schedule dates from gantt chart logic...');
console.log('[Dashboard] Using existing gantt dates:', window.ganttMinDate, window.ganttMaxDate);
```

## 향후 개선 사항

1. **이벤트 기반 업데이트**: CustomEvent를 사용한 간트차트 → 대시보드 통신
2. **캐싱 최적화**: 대시보드 데이터 캐싱으로 불필요한 재계산 방지
3. **에러 처리 강화**: 날짜 계산 실패 시 명확한 에러 메시지
4. **프로그레스 표시**: 대량 ActivityObject 처리 시 로딩 표시

## 관련 이슈

- Gantt chart duration handling (workings/92_*.md 참조)
- Dashboard calculation logic
- Global state management

## 추가 수정: 프로젝트 선택 시 즉시 대시보드 업데이트

### 추가 문제 상황
사용자가 프로젝트를 처음 선택하면 홈 탭이 먼저 표시되는데, 이 시점에서는 간트차트가 아직 로드되지 않아 공정계획 기간이 표시되지 않는 문제가 있었습니다.

### 추가 해결 방법

#### 1. 간트차트 계산 로직 재사용
**파일**: `connections/static/connections/home_tab_handlers.js`
**위치**: Line 650-799 (calculateScheduleDatesFromGantt 함수)

간트차트가 렌더링되지 않은 경우에도 정확한 날짜를 계산하도록 `generateGanttData` 함수를 직접 호출:

```javascript
// 1. CostItem별로 ActivityObject 그룹핑
const costItemMap = new Map();
window.loadedActivityObjects.forEach(ao => {
    if (!ao.cost_item || !ao.activity) return;
    const ciId = ao.cost_item.id;
    if (!costItemMap.has(ciId)) {
        costItemMap.set(ciId, {
            ...ao.cost_item,
            activityObjects: []
        });
    }
    costItemMap.get(ciId).activityObjects.push(ao);
});

// 2. Activity와 Dependency 데이터 추출
const activities = [];
const dependencies = [];
window.loadedActivityObjects.forEach(ao => {
    if (ao.activity && !activityIdSet.has(ao.activity.id)) {
        activities.push(ao.activity);
        // Dependency 추출
        if (ao.activity.predecessors && Array.isArray(ao.activity.predecessors)) {
            ao.activity.predecessors.forEach(pred => {
                dependencies.push({
                    predecessor_id: pred.id,
                    successor_id: ao.activity.id,
                    lag: pred.lag || 0,
                    lag_type: pred.lag_type || 'days'
                });
            });
        }
    }
});

// 3. 간트차트 핸들러의 generateGanttData 함수 호출
if (typeof window.generateGanttData === 'function') {
    const ganttTasks = window.generateGanttData(costItems, activities, dependencies, window.loadedActivityObjects);

    if (ganttTasks && ganttTasks.length > 0) {
        const allDates = ganttTasks.flatMap(t => [new Date(t.start), new Date(t.end)]);
        const minDate = new Date(Math.min(...allDates));
        const maxDate = new Date(Math.max(...allDates));
        const totalDays = Math.ceil((maxDate - minDate) / (1000 * 60 * 60 * 24));

        return {
            start_date_formatted: minDate.toLocaleDateString('ko-KR'),
            end_date_formatted: maxDate.toLocaleDateString('ko-KR'),
            total_days: totalDays
        };
    }
}
```

**효과**:
- 간트차트 탭을 방문하지 않아도 정확한 프로젝트 기간 계산
- 선행관계, offset, lag 모두 고려한 정확한 날짜 계산
- Fallback으로 간단한 계산도 제공

#### 2. 간트차트 함수 전역 노출
**파일**: `connections/static/connections/gantt_chart_handlers.js`
**위치**: Line 1778-1780

```javascript
// 대시보드에서 간트차트 날짜 계산 로직 재사용을 위해 전역 노출
window.generateGanttData = generateGanttData;
window.calculateTaskDates = calculateTaskDates;
```

**효과**: 대시보드에서 간트차트의 정확한 계산 로직 재사용 가능

### 업데이트된 데이터 흐름

```
프로젝트 선택
  ↓
홈 탭 표시 (간트차트 미로드)
  ↓
loadHomeDashboardData(projectId)
  ↓
loadedActivityObjects 로드
  ↓
calculateScheduleDatesFromGantt()
  ├─ window.ganttMinDate 확인 → 없음
  └─ generateGanttData() 직접 호출
      ├─ CostItem 그룹핑
      ├─ Activity/Dependency 추출
      ├─ 간트 태스크 생성
      ├─ 선행관계 계산
      ├─ offset/lag 적용
      └─ 날짜 계산 완료
  ↓
updateDashboardUI(data)
  └─ 공정계획 카드 업데이트 ✓
```

### 계산 우선순위

1. **최우선**: `window.ganttMinDate`/`window.ganttMaxDate` (간트차트 이미 렌더링됨)
2. **차선**: `window.generateGanttData()` 호출 (정확한 계산 재사용)
3. **마지막**: 간단한 duration 합산 (fallback)

## 추가 수정 2: 프로젝트 시작일 설정 누락 문제

### 추가 문제 상황
처음 프로젝트를 선택하여 홈 탭에서 대시보드를 로드할 때, 날짜가 "1970. 1. 1."로 표시되는 문제가 발생했습니다.

**로그 분석**:
```
[Dashboard] Calculated dates using gantt logic: Thu Jan 01 1970 09:00:00 GMT+0900
```

### 원인 분석
`generateGanttData` 함수는 `projectStartDate` 전역 변수를 사용하여 날짜를 계산하는데, 대시보드에서 이 함수를 호출할 때 `projectStartDate`가 설정되지 않아 `new Date(null)` 또는 `new Date(undefined)`가 되어 1970년 1월 1일(Unix epoch)로 계산되었습니다.

### 해결 방법

#### 1. 프로젝트 시작일 설정 추가
**파일**: `connections/static/connections/home_tab_handlers.js`
**위치**: Line 708-727

```javascript
// 프로젝트 시작일 가져오기 (localStorage에서 - 간트차트와 동일한 방식)
const savedStartDate = localStorage.getItem(`project_${window.currentProjectId}_start_date`);
let projectStartDate;
if (savedStartDate) {
    projectStartDate = new Date(savedStartDate);
} else {
    // 기본값: 오늘
    projectStartDate = new Date();
}

console.log('[Dashboard] Using project start date:', projectStartDate.toISOString().split('T')[0]);

// 간트차트 핸들러가 사용하는 전역 변수 설정
if (typeof window.setProjectStartDate === 'function') {
    window.setProjectStartDate(projectStartDate);
} else {
    // setProjectStartDate 함수가 없으면 직접 설정
    window.projectStartDate = projectStartDate;
}
```

#### 2. ActivityMap 생성 추가
**파일**: `connections/static/connections/home_tab_handlers.js`
**위치**: Line 686

`calculateTaskDates` 함수에서 사용하는 `activityMap` 생성:
```javascript
const activityMap = new Map();
window.loadedActivityObjects.forEach(ao => {
    if (ao.activity && !activityIdSet.has(ao.activity.id)) {
        activities.push(ao.activity);
        activityIdSet.add(ao.activity.id);
        activityMap.set(ao.activity.id, ao.activity); // activityMap에 추가
        // ...
    }
});
```

#### 3. 프로젝트 시작일 전역 노출
**파일**: `connections/static/connections/gantt_chart_handlers.js`
**위치**: Line 24-27

```javascript
// 대시보드에서 프로젝트 시작일 설정을 위해 전역으로 노출
Object.defineProperty(window, 'projectStartDate', {
    get: () => projectStartDate,
    set: (value) => { projectStartDate = value; }
});
```

### 완성된 데이터 흐름

```
프로젝트 선택 (홈 탭)
  ↓
loadHomeDashboardData(projectId)
  ↓
loadedActivityObjects 로드
  ↓
calculateScheduleDatesFromGantt()
  ├─ window.ganttMinDate 확인 → 없음
  ├─ localStorage에서 프로젝트 시작일 읽기
  ├─ window.projectStartDate 설정 ✓
  ├─ CostItem 그룹핑
  ├─ Activity/Dependency 추출
  ├─ ActivityMap 생성 ✓
  └─ generateGanttData() 호출
      ├─ projectStartDate 사용 ✓
      ├─ 간트 태스크 생성
      └─ calculateTaskDates() 호출
          ├─ activityMap 사용 ✓
          ├─ 선행관계 계산
          ├─ offset/lag 적용
          └─ 정확한 날짜 계산 완료
  ↓
updateDashboardUI(data)
  └─ 공정계획 카드 업데이트: "2025. 11. 7. ~ 2025. 12. 30. (53일)" ✓
```

### 테스트 결과

**수정 전**:
```
[Dashboard] Calculated dates: 1970. 1. 1. ~ 1970. 1. 23. (22일)
```

**수정 후**:
```
[Dashboard] Using project start date: 2025-11-06
[Dashboard] Calculated dates: 2025. 11. 7. ~ 2025. 12. 30. (53일)
```

## 작업 시간
- 날짜: 2025-11-07
- 소요 시간: 약 1시간
- 작업자: Claude Code (Anthropic)
