# 플라이 모드 및 카메라 컨트롤 개선

**날짜**: 2025-10-31
**작업자**: Claude Code

## 개요

3D 뷰어에 Twinmotion/Unity/Unreal 스타일의 플라이 모드를 구현하고, Blender/Revit 스타일의 선택 객체 중심 회전 기능을 개선했습니다. 여러 카메라 점프 문제를 해결하고, 복수 객체 선택 시 가시성 제어 버튼의 버그를 수정했습니다.

## 구현된 기능

### 1. Shift + 우클릭: 선택 객체 중심 회전 (Orbit Around Selection)

**동작 방식:**
- Shift + 마우스 우클릭 + 드래그: 선택된 객체를 중심으로 카메라 회전
- 회전 시작 시 `controls.target`을 선택된 객체 중심으로 설정
- 회전 중에는 화면이 이동하지 않음 (카메라 위치만 변경)
- 마우스 버튼을 놓으면 즉시 회전 중지

**Blender/Revit 스타일 구현:**
```javascript
// onPointerDown - Shift + 우클릭 감지
if (event.button === 2 && event.shiftKey) {
    event.preventDefault();
    event.stopImmediatePropagation();

    // controls.target만 설정, 화면은 이동하지 않음
    if (selectedObjectsCenter) {
        controls.target.copy(selectedObjectsCenter);
    }

    controls.enabled = false;
    isShiftRightRotating = true;
    lastRotateX = event.clientX;
    lastRotateY = event.clientY;
    return;
}
```

**회전 로직 (Quaternion 기반):**
```javascript
// onPointerMove - Shift + 우클릭 회전
if (isShiftRightRotating) {
    const deltaX = event.clientX - lastRotateX;
    const deltaY = event.clientY - lastRotateY;

    const rotationCenter = controls.target.clone();

    // Quaternion 기반 회전
    const rotateSpeed = 0.005;
    const horizontalAngle = -deltaX * rotateSpeed;
    const verticalAngle = -deltaY * rotateSpeed;

    // 카메라 위치를 회전 중심 기준 offset으로 변환
    let offset = camera.position.clone().sub(rotationCenter);
    const distance = offset.length();

    // Y축 기준 좌우 회전 (World space)
    const qy = new THREE.Quaternion().setFromAxisAngle(
        new THREE.Vector3(0, 1, 0),
        horizontalAngle
    );
    offset.applyQuaternion(qy);

    // Right 벡터 기준 상하 회전
    const up = new THREE.Vector3(0, 1, 0);
    const right = new THREE.Vector3();
    right.crossVectors(up, offset).normalize();
    const qx = new THREE.Quaternion().setFromAxisAngle(right, verticalAngle);
    offset.applyQuaternion(qx);

    // 거리 유지
    offset.normalize().multiplyScalar(distance);

    // 새 카메라 위치
    camera.position.copy(rotationCenter).add(offset);
    camera.lookAt(rotationCenter);

    return;
}
```

### 2. 우클릭 + WASD: 플라이 모드 (First-Person Camera)

**동작 방식:**
- 우클릭 홀드: 플라이 모드 진입
- 우클릭 + 마우스 드래그: 1인칭 시점 회전
- 우클릭 + WASD: 이동 (전진/후진/좌우 스트레이프)
- 우클릭 + Q/E: 수직 이동 (하강/상승)

**키보드 매핑:**
```javascript
let keys = {
    w: false,  // 전진
    a: false,  // 왼쪽 이동
    s: false,  // 후진
    d: false,  // 오른쪽 이동
    q: false,  // 하강
    e: false   // 상승
};
```

**이동 처리 (animate 루프):**
```javascript
// ▼▼▼ WASDQE 플라이 모드 (우클릭 홀드 시) ▼▼▼
if (isRightClickHeld) {
    const moveSpeed = 10 * delta;
    const forward = new THREE.Vector3();
    const right = new THREE.Vector3();
    const up = new THREE.Vector3(0, 1, 0);  // World up

    camera.getWorldDirection(forward);
    right.crossVectors(forward, camera.up).normalize();
    forward.normalize();

    // Twinmotion/Unity/Unreal 스타일 이동
    if (keys.w) camera.position.addScaledVector(forward, moveSpeed);
    if (keys.s) camera.position.addScaledVector(forward, -moveSpeed);
    if (keys.a) camera.position.addScaledVector(right, -moveSpeed);
    if (keys.d) camera.position.addScaledVector(right, moveSpeed);
    if (keys.e) camera.position.addScaledVector(up, moveSpeed);
    if (keys.q) camera.position.addScaledVector(up, -moveSpeed);

    // ⭐ controls.target을 매 프레임마다 업데이트 (종료 시 점프 방지)
    const lookAhead = new THREE.Vector3(0, 0, -1);
    lookAhead.applyQuaternion(camera.quaternion);
    controls.target.copy(camera.position).add(lookAhead.multiplyScalar(10));
}
```

**1인칭 시점 회전:**
```javascript
// onPointerMove - 우클릭 드래그
if (isRightClickHeld) {
    const deltaX = event.clientX - lastRotateX;
    const deltaY = event.clientY - lastRotateY;

    const rotateSpeed = 0.002;

    // Y축 기준 좌우 회전 (수평)
    const eulerY = new THREE.Euler(0, -deltaX * rotateSpeed, 0, 'YXZ');
    camera.quaternion.premultiply(new THREE.Quaternion().setFromEuler(eulerY));

    // X축 기준 상하 회전 (수직)
    const eulerX = new THREE.Euler(-deltaY * rotateSpeed, 0, 0, 'YXZ');
    camera.quaternion.multiply(new THREE.Quaternion().setFromEuler(eulerX));

    // controls.target 업데이트
    const forward = new THREE.Vector3(0, 0, -1);
    forward.applyQuaternion(camera.quaternion);
    controls.target.copy(camera.position).add(forward.multiplyScalar(10));

    return;
}
```

### 3. OrbitControls 마우스 버튼 설정

```javascript
controls.mouseButtons = {
    LEFT: null,                    // 좌클릭 비활성화 (박스 선택용)
    MIDDLE: THREE.MOUSE.PAN,       // 중간 버튼 = 이동
    RIGHT: null                    // 우클릭은 커스텀 처리
};
```

## 해결된 문제들

### 문제 1: 카메라 점프 (초기)

**증상:**
- 우클릭하는 순간 화면이 갑자기 이동
- 휠 버튼 클릭 시에도 화면이 이동

**원인:**
- `lastRotateX`, `lastRotateY`가 초기화되지 않음
- 이벤트가 OrbitControls로 전달됨

**해결 방법:**
```javascript
// onPointerDown에서
event.preventDefault();
event.stopImmediatePropagation();
controls.enabled = false;  // OrbitControls 비활성화
lastRotateX = event.clientX;  // ⭐ 초기화
lastRotateY = event.clientY;
```

### 문제 2: 회전이 마우스 버튼 놓아도 계속됨

**증상:**
- Shift + 우클릭으로 회전 시작 후, 마우스 버튼 놓아도 회전 계속됨

**원인:**
- `controls.enabled`가 `false`여도 `controls.update()`가 호출됨

**해결 방법:**
```javascript
// animate()에서
if (controls && controls.enabled) {  // ⭐ enabled 체크 추가
    controls.update();
}
```

### 문제 3: 회전 시 화면이 선택된 객체 중심으로 이동

**증상:**
- Shift + 우클릭 회전 시, 화면이 선택된 객체를 중심으로 이동함
- 사용자는 회전만 하고 싶은데 화면이 움직임

**원인:**
- 회전하는 동안 `controls.target`을 계속 업데이트함

**해결 방법:**
```javascript
// onPointerDown에서 한 번만 설정
if (selectedObjectsCenter) {
    controls.target.copy(selectedObjectsCenter);
}

// onPointerMove에서는 제거
// controls.target.copy(rotationCenter); // ❌ 삭제
```

### 문제 4: 복수 객체 선택 시 가시성 버튼 오작동

**증상:**
- 여러 객체를 선택하고 '선택 숨기기' 또는 '선택만 보기' 버튼 클릭 시
- 한 개 객체만 숨겨지거나 표시됨

**원인:**
- `isolateSelection()`과 `hideSelection()` 함수가 `selectedObject` (단일)만 체크
- `selectedObjects` (배열)을 처리하지 않음

**해결 방법:**
```javascript
function isolateSelection() {
    // ▼▼▼ 복수 선택 지원 ▼▼▼
    if (selectedObjects.length === 0 && !selectedObject) {
        showToast('객체를 먼저 선택해주세요', 'warning');
        return;
    }

    // 선택된 모든 객체의 ID 수집
    const selectedIds = new Set();

    // selectedObjects 배열에서 ID 수집
    selectedObjects.forEach(obj => {
        const id = getObjectId(obj);
        if (id) selectedIds.add(id);
    });

    // selectedObject가 있으면 추가 (단일 선택 호환성)
    if (selectedObject) {
        const id = getObjectId(selectedObject);
        if (id) selectedIds.add(id);
    }

    // 선택되지 않은 모든 객체 숨기기
    scene.traverse((object) => {
        if (object.isMesh) {
            const objectId = getObjectId(object);
            if (objectId && !selectedIds.has(objectId)) {
                object.visible = false;
                hiddenObjectIds.add(objectId);
            }
        }
    });

    showToast(`선택된 ${selectedIds.size}개 객체만 표시`, 'success');
}

function hideSelection() {
    // ▼▼▼ 복수 선택 지원 ▼▼▼
    const selectedIds = new Set();
    let hiddenCount = 0;

    // selectedObjects 배열에서 숨기기
    selectedObjects.forEach(obj => {
        const id = getObjectId(obj);
        if (id) {
            obj.visible = false;
            hiddenObjectIds.add(id);
            selectedIds.add(id);
            hiddenCount++;
        }
    });

    // selectedObject가 있으면 숨기기
    if (selectedObject) {
        const id = getObjectId(selectedObject);
        if (id) {
            selectedObject.visible = false;
            hiddenObjectIds.add(id);
            selectedIds.add(id);
            hiddenCount++;
        }
    }

    showToast(`선택된 ${hiddenCount}개 객체를 숨겼습니다`, 'success');
}
```

### 문제 5: 플라이 모드 종료 시 카메라 점프

**증상:**
- 우클릭 + WASD로 이동한 후
- 우클릭을 놓으면 화면이 살짝 이동함

**원인:**
- OrbitControls를 다시 활성화할 때
- `controls.target`이 카메라가 바라보는 방향과 일치하지 않음

**해결 방법 1 - onPointerUp에서 명시적 업데이트:**
```javascript
// onPointerUp - 우클릭 플라이 모드 종료
if (isRightClickHeld) {
    event.preventDefault();
    event.stopImmediatePropagation();

    // ⭐ controls.target을 현재 카메라가 바라보는 방향으로 업데이트
    const forward = new THREE.Vector3(0, 0, -1);
    forward.applyQuaternion(camera.quaternion);
    controls.target.copy(camera.position).add(forward.multiplyScalar(10));

    isRightClickHeld = false;
    controls.enabled = true;  // OrbitControls 재활성화

    return;
}
```

**해결 방법 2 - animate 루프에서 지속적 업데이트:**
```javascript
// animate() - 플라이 모드 중
if (isRightClickHeld) {
    // WASD 이동 로직...

    // ⭐ controls.target을 매 프레임마다 업데이트 (종료 시 점프 방지)
    const lookAhead = new THREE.Vector3(0, 0, -1);
    lookAhead.applyQuaternion(camera.quaternion);
    controls.target.copy(camera.position).add(lookAhead.multiplyScalar(10));
}
```

**핵심 원리:**
- 플라이 모드 중에는 카메라가 자유롭게 회전/이동
- `controls.target`을 항상 카메라가 바라보는 방향 10 단위 앞으로 설정
- OrbitControls 재활성화 시, 카메라가 이미 올바른 방향을 보고 있어서 점프 없음

## 변경된 파일

### `connections/static/connections/three_d_viewer.js`

**추가된 변수:**
```javascript
let isShiftRightRotating = false;    // Shift + 우클릭 회전 중
let isRightClickHeld = false;        // 우클릭 홀드 (플라이 모드)
let lastRotateX = 0;
let lastRotateY = 0;
let keys = { w: false, a: false, s: false, d: false, q: false, e: false };
```

**수정된 함수:**
- `animate()` (lines 206-230): 플라이 모드 이동 처리 및 `controls.target` 업데이트
- `onPointerDown()` (lines 1145-1169): Shift + 우클릭 감지 및 우클릭 플라이 모드 진입
- `onPointerMove()` (lines 1199-1265): Shift + 우클릭 회전 및 1인칭 시점 회전
- `onPointerUp()` (lines 1431-1449): 플라이 모드 종료 및 `controls.target` 업데이트
- `onKeyDown()` (lines 1382-1394): WASDQE 키 입력 처리
- `onKeyUp()` (lines 1396-1406): WASDQE 키 해제 처리
- `isolateSelection()` (lines 5919-5976): 복수 객체 지원
- `hideSelection()` (lines 5981-6037): 복수 객체 지원

## 기술적 특징

### Quaternion 기반 회전

**장점:**
- 짐벌락(Gimbal Lock) 없음
- 부드럽고 안정적인 회전
- 회전 축과 각도를 명확하게 제어

**사용 예:**
```javascript
const qy = new THREE.Quaternion().setFromAxisAngle(
    new THREE.Vector3(0, 1, 0),  // Y축 (수직)
    horizontalAngle
);
offset.applyQuaternion(qy);
```

### controls.target 관리 전략

**핵심 원칙:**
1. **모드 진입 시**: 적절한 위치로 한 번만 설정
2. **모드 실행 중**: 필요한 경우에만 업데이트 (플라이 모드)
3. **모드 종료 시**: 카메라 상태와 동기화 후 controls 재활성화

**타이밍:**
```
Shift + 우클릭 회전:
  onPointerDown → controls.target 설정 → controls.enabled = false
  onPointerMove → 카메라만 회전, target 변경 안 함
  onPointerUp   → controls.enabled = true

플라이 모드:
  onPointerDown → controls.enabled = false
  animate()     → 매 프레임 controls.target 업데이트
  onPointerUp   → controls.target 최종 동기화 → controls.enabled = true
```

### 이벤트 우선순위

**체크 순서 (중요!):**
```javascript
// 1. Shift + 우클릭 (먼저 체크!)
if (event.button === 2 && event.shiftKey) { ... }

// 2. 우클릭 (나중에 체크)
if (event.button === 2) { ... }
```

**이유**: JavaScript는 if 문을 순차적으로 평가하므로, 더 구체적인 조건을 먼저 체크해야 함.

## 사용자 경험

### Before (개선 전)

❌ 우클릭 시 카메라가 갑자기 이동
❌ 회전이 마우스 놓아도 계속됨
❌ 회전 시 화면이 중심으로 이동
❌ 복수 객체 선택 시 가시성 버튼 오작동
❌ 플라이 모드 종료 시 화면 점프

### After (개선 후)

✅ 부드러운 카메라 제어
✅ 마우스 버튼 상태에 정확히 반응
✅ 회전 시 화면 고정, 카메라만 회전
✅ 복수 객체 선택 완벽 지원
✅ 플라이 모드 종료 시 위치 유지

## 비교: 업계 표준 소프트웨어

| 기능 | Blender | Revit | Twinmotion | 본 구현 |
|------|---------|-------|------------|---------|
| 선택 중심 회전 | Numpad . | F (선택 후) | N/A | Shift + 우클릭 |
| 플라이 모드 | Shift + ` | N/A | 우클릭 | 우클릭 + WASD |
| 1인칭 회전 | 마우스 이동 | N/A | 우클릭 + 드래그 | 우클릭 + 드래그 |
| 수직 이동 | Q/E | N/A | Q/E | Q/E |
| 수평 이동 | WASD | N/A | WASD | WASD |

## 테스트 시나리오

### 테스트 1: Shift + 우클릭 회전
1. ✅ 객체 선택
2. ✅ Shift + 우클릭 + 드래그
3. ✅ 선택된 객체를 중심으로 회전
4. ✅ 화면이 객체 중심으로 이동하지 않음
5. ✅ 마우스 버튼 놓으면 즉시 회전 중지

### 테스트 2: 플라이 모드
1. ✅ 우클릭 홀드
2. ✅ WASD로 이동 (전진/후진/좌우)
3. ✅ Q/E로 수직 이동
4. ✅ 마우스 드래그로 시점 회전
5. ✅ 우클릭 놓으면 정확한 위치에 정지

### 테스트 3: 복수 객체 가시성
1. ✅ Ctrl/Cmd + 클릭으로 여러 객체 선택
2. ✅ '선택만 보기' 클릭 → 선택된 모든 객체만 표시
3. ✅ '모두 보기' 클릭 → 전체 복원
4. ✅ 다시 여러 객체 선택
5. ✅ '선택 숨기기' 클릭 → 선택된 모든 객체 숨김

### 테스트 4: 카메라 점프 방지
1. ✅ 우클릭 누르는 순간 → 점프 없음
2. ✅ Shift + 우클릭 누르는 순간 → 점프 없음
3. ✅ 플라이 모드에서 이동 후 종료 → 점프 없음
4. ✅ 회전 모드에서 회전 후 종료 → 점프 없음

## 성능 고려사항

### animate() 루프
- 플라이 모드 중 매 프레임 `controls.target` 업데이트
- 벡터 연산 3~4회 (forward, right, up 계산)
- 60fps에서도 성능 저하 없음

### 이벤트 처리
- `preventDefault()`, `stopImmediatePropagation()` 사용
- 불필요한 이벤트 버블링 방지
- OrbitControls와의 충돌 방지

## 알려진 제한사항

1. **플라이 모드 이동 속도**: 고정값 (`moveSpeed = 10 * delta`)
   - 향후 개선: 사용자 설정 가능하도록

2. **회전 감도**: 고정값 (`rotateSpeed = 0.005`, `0.002`)
   - 향후 개선: 마우스 감도 설정

3. **키보드 레이아웃**: QWERTY 기준
   - AZERTY 등 다른 레이아웃 미지원

## 향후 개선 방향

1. **설정 UI**
   - 이동 속도 조절
   - 마우스 감도 조절
   - 키 바인딩 커스터마이징

2. **추가 기능**
   - Shift 키 없이 선택 객체 중심 회전 (단축키 옵션)
   - 플라이 모드 속도 증감 (Shift = 빠르게, Ctrl = 느리게)
   - 카메라 북마크 (위치 저장/불러오기)

3. **접근성**
   - 키보드만으로 모든 기능 사용 가능
   - 화면 리더 지원
   - 고대비 모드 지원

## 참고 자료

- Three.js OrbitControls 문서
- Quaternion 수학 (3D 회전)
- Blender 카메라 네비게이션
- Twinmotion 플라이 모드
- StackOverflow: Orbit around selection

## 커밋 정보

- 변경 파일: 1개 (`connections/static/connections/three_d_viewer.js`)
- 추가: 플라이 모드 및 Orbit Around Selection 구현
- 수정: 카메라 점프 문제 해결, 복수 객체 가시성 버그 수정
- 삭제: 없음
