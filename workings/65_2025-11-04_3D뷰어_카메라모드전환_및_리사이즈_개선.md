# 65_2025-11-04_3D뷰어_카메라모드전환_및_리사이즈_개선.md

**날짜**: 2025년 11월 4일
**작업자**: Claude Code
**카테고리**: 3D Viewer, UI/UX Improvement

## 📋 작업 요약

3D 뷰어에 투시/직교 카메라 모드 전환 기능을 추가하고, 스플릿바 리사이즈 시 캔버스가 올바르게 리사이즈되도록 개선했습니다.

## 🎯 주요 기능

### 1. 카메라 모드 전환 기능 추가
- **투시(Perspective) 모드**: 원근감이 있는 기본 카메라 뷰
- **직교(Orthographic) 모드**: 원근감 없이 모든 거리가 동일한 스케일로 표시되는 뷰
- 버튼 클릭으로 실시간 전환 가능
- 카메라 위치와 타겟이 모드 전환 시에도 유지됨

### 2. 3D 뷰포트 리사이즈 개선
- 스플릿바 드래그 시 3D 캔버스가 실시간으로 리사이즈
- 카메라 aspect ratio 자동 업데이트로 비율 왜곡 방지
- PerspectiveCamera와 OrthographicCamera 모두 올바르게 처리

## 📝 상세 변경 내용

### 파일 1: `connections/templates/three_d_viewer.html`

**위치**: Lines 43-47

**변경 내용**: 카메라 모드 전환 버튼 추가

```html
<!-- 카메라 모드 그룹 -->
<div class="button-group camera-group">
    <button id="perspective-mode-btn" class="active">투시</button>
    <button id="orthographic-mode-btn">직교</button>
</div>
```

**설명**:
- 버튼 그룹으로 시각적 그룹핑
- 기본값은 투시 모드 (active 클래스)
- 간결한 한글 레이블

---

### 파일 2: `connections/static/connections/style.css`

**위치**: Lines 3387-3402

**변경 내용**: 카메라 모드 버튼 스타일링

```css
/* 카메라 모드 그룹 스타일 */
.button-group.camera-group button {
    background-color: #6c757d;
}

.button-group.camera-group button:hover:not(:disabled) {
    background-color: #5a6268;
}

.button-group.camera-group button.active {
    background-color: #28a745;
}

.button-group.camera-group button.active:hover {
    background-color: #218838;
}
```

**설명**:
- 기본 상태: 회색 (#6c757d)
- 활성 상태: 녹색 (#28a745)
- 호버 효과 포함

---

### 파일 3: `connections/static/connections/three_d_viewer.js`

#### 변경 3-1: 카메라 모드 전환 이벤트 리스너

**위치**: Lines 924-945

**변경 내용**:

```javascript
// ▼▼▼ [추가] 카메라 모드 전환 버튼 ▼▼▼
const perspectiveModeBtn = document.getElementById('perspective-mode-btn');
const orthographicModeBtn = document.getElementById('orthographic-mode-btn');

if (perspectiveModeBtn && orthographicModeBtn) {
    // 투시 모드로 전환
    perspectiveModeBtn.onclick = function() {
        console.log("[3D Viewer] Switching to Perspective Camera mode.");
        switchCameraMode('perspective');
        perspectiveModeBtn.classList.add('active');
        orthographicModeBtn.classList.remove('active');
    };

    // 직교 모드로 전환
    orthographicModeBtn.onclick = function() {
        console.log("[3D Viewer] Switching to Orthographic Camera mode.");
        switchCameraMode('orthographic');
        orthographicModeBtn.classList.add('active');
        perspectiveModeBtn.classList.remove('active');
    };
}
// ▲▲▲ [추가] 여기까지 ▲▲▲
```

**설명**:
- 버튼 클릭 시 `switchCameraMode()` 호출
- active 클래스 토글로 시각적 피드백 제공

---

#### 변경 3-2: 카메라 모드 전환 함수

**위치**: Lines 350-404

**변경 내용**:

```javascript
// ▼▼▼ [추가] 카메라 모드 전환 함수 ▼▼▼
function switchCameraMode(mode) {
    if (!camera || !controls || !renderer) {
        console.error("[3D Viewer] Camera, controls, or renderer not initialized!");
        return;
    }

    const container = document.querySelector('.three-d-viewer-container');
    if (!container) {
        console.error("[3D Viewer] Container not found!");
        return;
    }

    const width = container.clientWidth;
    const height = container.clientHeight;

    // 현재 카메라의 위치와 타겟 저장
    const position = camera.position.clone();
    const target = controls.target.clone();

    // 새로운 카메라 생성
    let newCamera;
    if (mode === 'perspective') {
        newCamera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
    } else if (mode === 'orthographic') {
        const aspect = width / height;
        const frustumSize = 20; // 직교 카메라의 뷰 크기 조정
        newCamera = new THREE.OrthographicCamera(
            frustumSize * aspect / -2,
            frustumSize * aspect / 2,
            frustumSize / 2,
            frustumSize / -2,
            0.1,
            1000
        );
    } else {
        console.error("[3D Viewer] Unknown camera mode:", mode);
        return;
    }

    // 저장된 위치와 타겟 복원
    newCamera.position.copy(position);
    newCamera.lookAt(target);

    // 전역 카메라 참조 업데이트
    camera = newCamera;
    window.camera = newCamera;

    // 컨트롤 업데이트
    controls.object = newCamera;
    controls.target.copy(target);
    controls.update();

    console.log(`[3D Viewer] Camera mode switched to ${mode}`);
}
// ▲▲▲ [추가] 여기까지 ▲▲▲
```

**설명**:
- 현재 카메라의 위치와 타겟을 저장
- 요청된 모드에 맞는 새 카메라 생성
- 저장된 위치/타겟을 새 카메라에 적용
- OrbitControls도 새 카메라로 업데이트

---

#### 변경 3-3: onWindowResize 함수 개선

**위치**: Lines 326-348

**변경 내용**:

```javascript
function onWindowResize() {
    const container = document.querySelector('.three-d-viewer-container');
    if (!container || !camera || !renderer) return;

    const width = container.clientWidth;
    const height = container.clientHeight;

    // 카메라 타입에 따라 다르게 처리
    if (camera.isPerspectiveCamera) {
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
    } else if (camera.isOrthographicCamera) {
        const aspect = width / height;
        const frustumSize = 20;
        camera.left = frustumSize * aspect / -2;
        camera.right = frustumSize * aspect / 2;
        camera.top = frustumSize / 2;
        camera.bottom = frustumSize / -2;
        camera.updateProjectionMatrix();
    }

    renderer.setSize(width, height);
}
```

**설명**:
- PerspectiveCamera: aspect ratio 업데이트
- OrthographicCamera: frustum 경계 재계산
- 두 카메라 타입 모두 올바르게 처리

---

#### 변경 3-4: 전역 변수 노출

**위치**: Lines 241-246

**변경 내용**:

```javascript
// ▼▼▼ [추가] camera, renderer, controls를 전역으로 노출 ▼▼▼
window.camera = camera;
window.renderer = renderer;  // ← 추가됨
window.controls = controls;
window.scene = scene;
// ▲▲▲ [추가] 여기까지 ▲▲▲
```

**설명**:
- `window.renderer` 추가 (이전에 누락되어 있었음)
- revit_control.html의 `resize3DCanvas()` 함수에서 접근 가능하도록 함

---

### 파일 4: `connections/templates/revit_control.html`

#### 변경 4-1: resize3DCanvas 함수 개선

**위치**: Lines 3079-3121

**변경 내용**:

```javascript
// Function to properly resize 3D canvas
function resize3DCanvas() {
    console.log('[Layout] resize3DCanvas called');
    console.log('[Layout] window.camera:', !!window.camera);
    console.log('[Layout] window.renderer:', !!window.renderer);

    if (window.camera && window.renderer) {
        const canvas = document.getElementById('three-d-canvas');
        const viewportTop = document.getElementById('split-left-top');
        console.log('[Layout] canvas found:', !!canvas);
        console.log('[Layout] viewportTop found:', !!viewportTop);

        if (canvas && viewportTop) {
            const width = viewportTop.clientWidth;
            const height = viewportTop.clientHeight;
            console.log(`[Layout] Container size: ${width}x${height}`);

            // Update renderer size (updateStyle: true to also update CSS)
            window.renderer.setSize(width, height, true);

            // 카메라 타입에 따라 다르게 처리
            if (window.camera.isPerspectiveCamera) {
                // Update camera aspect ratio to prevent distortion
                window.camera.aspect = width / height;
                window.camera.updateProjectionMatrix();
                console.log(`[Layout] Resized 3D canvas to ${width}x${height}, aspect: ${window.camera.aspect.toFixed(2)}`);
            } else if (window.camera.isOrthographicCamera) {
                // Update orthographic camera frustum
                const aspect = width / height;
                const frustumSize = 20;
                window.camera.left = frustumSize * aspect / -2;
                window.camera.right = frustumSize * aspect / 2;
                window.camera.top = frustumSize / 2;
                window.camera.bottom = frustumSize / -2;
                window.camera.updateProjectionMatrix();
                console.log(`[Layout] Resized 3D canvas to ${width}x${height} (orthographic)`);
            }

            // Update OrbitControls if it exists
            if (window.controls && window.controls.update) {
                window.controls.update();
            }
        }
    }
}
```

**설명**:
- 디버깅 로그 추가 (추후 제거 가능)
- PerspectiveCamera와 OrthographicCamera 모두 처리
- 렌더러 크기와 카메라 projection 동시 업데이트

---

#### 변경 4-2: 스플릿바 이벤트 리스너 수정

**위치**: Lines 3126-3165

**변경 내용**:

```javascript
// 가로 스플릿바
document.addEventListener('mousemove', (e) => {
    if (!isDragging) return;

    const delta = e.clientX - startX;
    const newLeftWidth = startLeftWidth + delta;
    const totalWidth = splitWrapper.offsetWidth;
    const minWidth = 300;
    const maxWidth = totalWidth - minWidth - 8;

    if (newLeftWidth >= minWidth && newLeftWidth <= maxWidth) {
        const percentage = (newLeftWidth / totalWidth) * 100;
        leftPanel.style.flex = `0 0 ${percentage}%`;

        // ▼▼▼ [수정] setTimeout으로 DOM 업데이트 후 리사이즈 ▼▼▼
        if (resizeFrame) {
            clearTimeout(resizeFrame);
        }
        resizeFrame = setTimeout(() => {
            resize3DCanvas();
        }, 0);
        // ▲▲▲ [수정] 여기까지 ▲▲▲
    }
});

document.addEventListener('mouseup', () => {
    if (isDragging) {
        isDragging = false;
        document.body.style.cursor = '';
        document.body.style.userSelect = '';

        // ▼▼▼ [수정] setTimeout으로 DOM 업데이트 후 리사이즈 ▼▼▼
        if (resizeFrame) {
            clearTimeout(resizeFrame);
        }
        setTimeout(() => {
            resize3DCanvas();
        }, 0);
        // ▲▲▲ [수정] 여기까지 ▲▲▲
    }
});
```

**설명**:
- `requestAnimationFrame` → `setTimeout(..., 0)` 변경
- DOM 레이아웃 재계산 후 리사이즈 함수 실행
- 가로/세로 스플릿바 모두 동일한 방식 적용

---

**위치**: Lines 3188-3226 (세로 스플릿바)

**변경 내용**: 가로 스플릿바와 동일한 패턴 적용

---

## 🐛 해결된 문제

### 문제 1: window.renderer가 전역으로 노출되지 않음
**증상**: 스플릿바 드래그 시 `resize3DCanvas()` 함수가 호출되지만 실제 리사이즈가 작동하지 않음

**원인**: `three_d_viewer.js`에서 `renderer`를 `window.renderer`로 노출하지 않아서 `resize3DCanvas()`가 렌더러에 접근 불가

**해결**: Line 243에 `window.renderer = renderer;` 추가

---

### 문제 2: 스플릿바 드래그 시 비율 왜곡
**증상**:
- 세로 스플릿바 이동 시 3D 공간이 세로로 늘어남
- 가로 스플릿바 이동 시 캔버스 크기가 변하지 않음

**원인**:
- DOM 업데이트가 완료되기 전에 `resize3DCanvas()`가 실행되어 잘못된 크기 값 읽음
- `requestAnimationFrame`이 레이아웃 재계산보다 먼저 실행됨

**해결**: `setTimeout(..., 0)`으로 변경하여 DOM 업데이트 후 실행 보장

---

## 🧪 테스트 결과

### 테스트 1: 카메라 모드 전환
✅ 투시 → 직교 전환 시 카메라 위치 유지
✅ 직교 → 투시 전환 시 카메라 위치 유지
✅ 버튼 활성 상태 올바르게 표시
✅ 콘솔 로그 정상 출력

### 테스트 2: 스플릿바 리사이즈
✅ 가로 스플릿바 드래그 시 실시간 리사이즈
✅ 세로 스플릿바 드래그 시 실시간 리사이즈
✅ 투시 모드에서 aspect ratio 유지
✅ 직교 모드에서 frustum 올바르게 재계산
✅ 비율 왜곡 없음

### 테스트 3: 통합 테스트
✅ 직교 모드 + 스플릿바 리사이즈 정상 작동
✅ 투시 모드 + 스플릿바 리사이즈 정상 작동
✅ 브라우저 창 리사이즈 시 정상 작동

---

## 📊 성능 영향

- **초기 로딩 시간**: 변화 없음
- **메모리 사용량**: 카메라 객체 1개 추가 (미미)
- **리사이즈 성능**: `setTimeout` 사용으로 약간의 딜레이 있으나 체감 불가
- **전반적 영향**: 무시할 수준

---

## 🔄 향후 개선 가능 사항

1. **디버깅 로그 제거**: 프로덕션 배포 전 콘솔 로그 제거
2. **카메라 모드 상태 저장**: 사용자가 선택한 모드를 localStorage에 저장하여 다음 방문 시 복원
3. **Orthographic 줌 레벨 저장**: 직교 모드의 frustumSize를 동적으로 조정 가능하도록 개선
4. **애니메이션 효과**: 카메라 모드 전환 시 부드러운 트랜지션 추가

---

## 📚 관련 문서

- Three.js PerspectiveCamera: https://threejs.org/docs/#api/en/cameras/PerspectiveCamera
- Three.js OrthographicCamera: https://threejs.org/docs/#api/en/cameras/OrthographicCamera
- Three.js OrbitControls: https://threejs.org/docs/#examples/en/controls/OrbitControls

---

## ✅ 체크리스트

- [x] 카메라 모드 전환 버튼 UI 추가
- [x] 투시/직교 모드 전환 로직 구현
- [x] 카메라 위치/타겟 유지 기능
- [x] 스플릿바 리사이즈 개선
- [x] PerspectiveCamera aspect ratio 업데이트
- [x] OrthographicCamera frustum 재계산
- [x] window.renderer 전역 노출
- [x] setTimeout으로 DOM 업데이트 후 리사이즈
- [x] 테스트 완료
- [x] 문서화 완료

---

**작업 완료 시각**: 2025-11-04 11:46 KST
