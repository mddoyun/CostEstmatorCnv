# BOQ 분할 객체 필터링 지원

**날짜**: 2025-10-30
**작업자**: Claude Code

## 문제 상황

3D 뷰어에서 분할된 객체(split element)를 선택하고 "뷰어 선택 가져오기" 버튼을 클릭했을 때, 해당 분할 객체와 연관된 산출항목만 BOQ 집계표에 표시되어야 하는데, 필터링이 제대로 작동하지 않는 문제가 발생했습니다.

## 원인 분석

### 기존 필터링 로직

**Frontend (`boq_detailed_estimation_handlers.js`):**
```javascript
// 원본 객체의 raw_element_id만 필터링에 사용
boqFilteredRawElementIds.add(rawElementId);

const requestData = {
    group_by: groupByFields,
    display_by: displayByFields,
    raw_element_ids: rawElementIds,  // ← split_element_id 정보 없음
    filter_ai: filterAiChecked,
    filter_dd: filterDdChecked
};
```

**Backend (`connections/views.py`):**
```python
# raw_element_id로만 필터링
if raw_element_ids:
    items_qs = items_qs.filter(quantity_member__raw_element_id__in=raw_element_ids)
```

### 문제점

1. 분할된 객체는 `split_element_id`를 가지지만, 이 정보가 서버로 전송되지 않음
2. 백엔드에서 `split_element_id` 기반 필터링을 지원하지 않음
3. 분할 객체 선택 시 원본 객체의 `raw_element_id`로만 필터링하여 부정확한 결과 반환

## 해결 방법

### 1. Frontend 수정

**`handleBoqGetFromViewer()` 함수 수정:**

```javascript
if (splitElementId) {
    // 분할 객체인 경우: split_element_id로 필터링
    window.boqFilterSplitElementIds = window.boqFilterSplitElementIds || new Set();
    window.boqFilterSplitElementIds.clear();
    window.boqFilterSplitElementIds.add(splitElementId);
    console.log(`[DEBUG] BOQ 필터 적용 (분할 객체): split_element_id=${splitElementId}`);
} else {
    // 원본 객체인 경우: raw_element_id로 필터링
    boqFilteredRawElementIds.add(rawElementId);
    window.boqFilterSplitElementIds = window.boqFilterSplitElementIds || new Set();
    window.boqFilterSplitElementIds.clear();
    console.log(`[DEBUG] BOQ 필터 적용 (원본 객체): raw_element_id=${rawElementId}`);
}
```

**`generateBoqReport()` 함수 수정:**

```javascript
const splitElementIds = (window.boqFilterSplitElementIds && window.boqFilterSplitElementIds.size > 0)
    ? Array.from(window.boqFilterSplitElementIds)
    : [];

const requestData = {
    group_by: groupByFields,
    display_by: displayByFields,
    raw_element_ids: rawElementIds,
    split_element_ids: splitElementIds,  // ← 추가
    filter_ai: filterAiChecked,
    filter_dd: filterDdChecked
};
```

### 2. Backend 수정

**`generate_boq_report_api()` 함수 수정:**

```python
# 1. 요청 데이터에서 split_element_ids 파싱
split_element_ids = data.get('split_element_ids', [])

# 2. OR 로직으로 필터링 (raw_element_id 또는 split_element_id)
if raw_element_ids or split_element_ids:
    element_filter = Q()
    if raw_element_ids:
        element_filter |= Q(quantity_member__raw_element_id__in=raw_element_ids)
    if split_element_ids:
        element_filter |= Q(quantity_member__split_element_id__in=split_element_ids)
    items_qs = items_qs.filter(element_filter)
```

## 변경된 파일

1. **`connections/static/connections/boq_detailed_estimation_handlers.js`**
   - `handleBoqGetFromViewer()`: 분할 객체 ID와 원본 객체 ID를 구분하여 저장
   - `generateBoqReport()`: `split_element_ids`를 요청 데이터에 포함

2. **`connections/views.py`**
   - `generate_boq_report_api()`: `split_element_ids` 파라미터 파싱 추가
   - Django Q 객체를 사용한 OR 필터링 로직 구현

## 결과

### 정상 동작 시나리오

1. ✅ 원본 객체 선택 → raw_element_id 기반 필터링
2. ✅ 분할 객체 선택 → split_element_id 기반 필터링
3. ✅ 각 객체와 정확히 연관된 산출항목만 집계표에 표시
4. ✅ 디버그 로그로 어떤 타입의 필터가 적용되었는지 확인 가능

### 핵심 개선

- 분할 객체와 원본 객체를 명확히 구분하여 필터링
- 백엔드에서 OR 로직으로 두 타입의 필터를 모두 지원
- 사용자가 3D 뷰어에서 선택한 정확한 객체의 산출항목만 표시
- BOQ 집계표의 정확성 향상

## 기술적 세부사항

### Django Q 객체 활용

```python
element_filter = Q()
element_filter |= Q(quantity_member__raw_element_id__in=raw_element_ids)
element_filter |= Q(quantity_member__split_element_id__in=split_element_ids)
items_qs = items_qs.filter(element_filter)
```

- `Q()` 객체로 복잡한 쿼리 조건 생성
- `|=` 연산자로 OR 조건 추가
- 원본 객체와 분할 객체를 모두 지원하는 유연한 필터링

### 프론트엔드 상태 관리

```javascript
window.boqFilterSplitElementIds = new Set();  // 분할 객체 ID 집합
boqFilteredRawElementIds = new Set();          // 원본 객체 ID 집합
```

- 전역 Set 객체로 필터링 ID 관리
- 중복 방지 및 효율적인 ID 추가/삭제

## 커밋

- Commit: 4bdd684
- 파일: 2개 변경 (39 insertions, 7 deletions)
- Push: origin/main
