# 57. 액티비티 객체 API 400 에러 수정

**날짜**: 2025-11-04
**작업자**: Claude Code
**관련 이슈**: 수동 수량입력 및 자동 수량계산 시 400 Bad Request 에러 발생

## 작업 개요

액티비티 객체의 수동 수량입력과 자동 수량계산 기능 구현 직후, 사용자 테스트에서 모든 업데이트 작업이 400 Bad Request 에러로 실패하는 문제를 발견하고 수정했습니다.

## 문제 발견

### 사용자 보고

사용자가 다음 세 가지 기능을 테스트:
1. **수동 직접입력**: 숫자 12 입력 → 400 Bad Request
2. **수동 산식입력**: `{AO.quantity}` 산식 입력 → 산식 평가 성공 (22) → 400 Bad Request
3. **자동 수량계산**: 계산 성공 (22, 11, 11) → 각각 400 Bad Request

### 콘솔 로그 분석

```
[Log] [DEBUG][Manual AO Quantity] Direct mode: 12
[Error] Failed to load resource: the server responded with a status of 400 (Bad Request)
[Warning] [WARN] Failed to save item: "f92ee084-fbf8-4a74-8e24-7e315bfc5cc3"

[Log] [DEBUG][Manual AO Quantity] Formula mode: {AO.quantity}
[Log] [DEBUG][evaluateQuantityFormula] Result: 22
[Error] Failed to load resource: the server responded with a status of 400 (Bad Request)
[Warning] [WARN] Failed to save item: "f92ee084-fbf8-4a74-8e24-7e315bfc5cc3"

[Log] [DEBUG][Auto Calc] Auto calculating for AO f92ee084-...: 1 * 22 = 22
[Error] Failed to load resource: the server responded with a status of 400 (Bad Request)
[Warning] [WARN][Auto Calc] Failed to save AO f92ee084-...
```

**공통점**: 모든 경우에 **산식 평가는 성공**했지만 **서버 저장 시 실패**

## 원인 분석

### 문제 1: HTTP 메소드 불일치

**JavaScript 코드 (잘못된 부분)**:
```javascript
// 수동 직접입력 (activity_object_manager.js:1608)
const saveResponse = await fetch(`/connections/api/activity-objects/${currentProjectId}/`, {
    method: 'POST',  // ← 잘못됨: 업데이트인데 POST 사용
    body: JSON.stringify(item),
});

// 수동 산식입력 (activity_object_manager.js:1648)
const saveResponse = await fetch(`/connections/api/activity-objects/${currentProjectId}/`, {
    method: 'POST',  // ← 잘못됨
    body: JSON.stringify(item),
});

// 자동 수량계산 (activity_object_manager.js:2078)
const saveResponse = await fetch(`/connections/api/activity-objects/${currentProjectId}/`, {
    method: 'POST',  // ← 잘못됨
    body: JSON.stringify(ao),
});
```

**문제**:
- 기존 ActivityObject를 **업데이트**하는 작업인데 **POST** 메소드 사용
- POST는 **새로운 리소스 생성**용
- **PUT** 메소드를 사용해야 함

### 문제 2: API URL 형식 오류

**잘못된 URL**:
```
POST /connections/api/activity-objects/{project_id}/
```

**올바른 URL** (업데이트용):
```
PUT /connections/api/activity-objects/{project_id}/{ao_id}/
```

**문제**:
- URL에 `ao_id` 파라미터가 누락됨
- 서버의 PUT 핸들러는 `ao_id`가 필수 (`views.py:6239`)
- `ao_id` 없이 요청하면 400 에러 발생

### 문제 3: 서버 PUT 핸들러 필드 누락

**views.py의 PUT 핸들러 (수정 전)**:
```python
# views.py:6237-6273
elif request.method == 'PUT':
    # ...
    if 'quantity' in data:
        ao.quantity = data['quantity']
    if 'is_manual' in data:
        ao.is_manual = data['is_manual']
    if 'manual_formula' in data:
        ao.manual_formula = data['manual_formula']
    # ← quantity_expression 필드 처리 없음!
    if 'progress' in data:
        ao.progress = data['progress']
```

**문제**:
- JavaScript에서 `quantity_expression` 필드를 전송하는데
- 서버 PUT 핸들러에서 이 필드를 처리하지 않음
- 필드가 무시되거나 검증 오류 발생 가능

### 문제 4: 전체 객체 전송

**잘못된 방식**:
```javascript
// 전체 item 객체를 그대로 전송
item.quantity = directValue;
item.is_manual = true;
item.manual_formula = null;
body: JSON.stringify(item),  // ← 모든 필드 포함
```

**문제**:
- 불필요한 필드까지 모두 전송 (activity, cost_item, quantity_member 등)
- 서버에서 예상하지 않은 필드로 인해 검증 오류 가능
- 네트워크 대역폭 낭비
- 보안 위험 (의도하지 않은 필드 수정)

## 수정 내용

### 1. views.py - quantity_expression 필드 지원 추가

**파일**: `connections/views.py`
**위치**: Line 6259-6260, 6275-6276

**변경사항**:
```python
elif request.method == 'PUT':
    # ...
    if 'manual_formula' in data:
        ao.manual_formula = data['manual_formula']
    if 'quantity_expression' in data:  # ← 추가
        ao.quantity_expression = data['quantity_expression']
    if 'progress' in data:
        ao.progress = data['progress']
    # ...

    except Exception as e:
        print(f"[ERROR][activity_objects_api] PUT Error: {e}")
        import traceback  # ← 추가
        traceback.print_exc()  # ← 추가 (디버깅용)
        return JsonResponse({'status': 'error', 'message': f'수정 중 오류 발생: {str(e)}'}, status=400)
```

**개선사항**:
- `quantity_expression` JSON 필드 처리 추가
- `traceback.print_exc()`로 상세 에러 로그 출력
- 향후 디버깅 용이성 향상

### 2. JavaScript - 수동 직접입력 수정

**파일**: `connections/static/connections/activity_object_manager.js`
**위치**: Line 1599-1623

**변경 전**:
```javascript
for (const item of selectedItems) {
    item.quantity = directValue;
    item.is_manual = true;
    item.manual_formula = null;
    item.quantity_expression = {
        mode: 'direct',
        value: directValue
    };

    const saveResponse = await fetch(`/connections/api/activity-objects/${currentProjectId}/`, {
        method: 'POST',  // ← 문제
        headers: { /* ... */ },
        body: JSON.stringify(item),  // ← 전체 객체 전송
    });

    if (saveResponse.ok) {
        updatedCount++;
    } else {
        console.warn('[WARN] Failed to save item:', item.id);  // ← 에러 내용 없음
    }
}
```

**변경 후**:
```javascript
for (const item of selectedItems) {
    const updateData = {  // ← 필요한 필드만
        quantity: directValue,
        is_manual: true,
        manual_formula: null,
        quantity_expression: {
            mode: 'direct',
            value: directValue
        }
    };

    const saveResponse = await fetch(`/connections/api/activity-objects/${currentProjectId}/${item.id}/`, {  // ← ao_id 추가
        method: 'PUT',  // ← POST → PUT
        headers: { /* ... */ },
        body: JSON.stringify(updateData),  // ← 최소한의 데이터만
    });

    if (saveResponse.ok) {
        updatedCount++;
    } else {
        const errorText = await saveResponse.text();  // ← 에러 텍스트 읽기
        console.warn('[WARN] Failed to save item:', item.id, errorText);  // ← 에러 출력
    }
}
```

**주요 변경점**:
1. **HTTP 메소드**: `POST` → `PUT`
2. **URL**: `/{project_id}/` → `/{project_id}/{item.id}/`
3. **요청 바디**: 전체 객체 → 업데이트할 필드만 포함한 `updateData` 객체
4. **에러 처리**: 에러 텍스트를 읽어서 로그에 출력

### 3. JavaScript - 수동 산식입력 수정

**파일**: `connections/static/connections/activity_object_manager.js`
**위치**: Line 1641-1665

**변경 전**:
```javascript
for (const item of selectedItems) {
    const aoContext = buildActivityObjectContext(item);
    const calculatedQuantity = evaluateQuantityFormula(formula, aoContext);

    if (calculatedQuantity !== null && !isNaN(calculatedQuantity)) {
        item.quantity = calculatedQuantity;
        item.is_manual = true;
        item.manual_formula = formula;
        item.quantity_expression = {
            mode: 'formula',
            formula: formula
        };

        const saveResponse = await fetch(`/connections/api/activity-objects/${currentProjectId}/`, {
            method: 'POST',  // ← 문제
            body: JSON.stringify(item),  // ← 전체 객체 전송
        });

        if (saveResponse.ok) {
            updatedCount++;
        } else {
            console.warn('[WARN] Failed to save item:', item.id);
        }
    }
}
```

**변경 후**:
```javascript
for (const item of selectedItems) {
    const aoContext = buildActivityObjectContext(item);
    const calculatedQuantity = evaluateQuantityFormula(formula, aoContext);

    if (calculatedQuantity !== null && !isNaN(calculatedQuantity)) {
        const updateData = {  // ← 필요한 필드만
            quantity: calculatedQuantity,
            is_manual: true,
            manual_formula: formula,
            quantity_expression: {
                mode: 'formula',
                formula: formula
            }
        };

        const saveResponse = await fetch(`/connections/api/activity-objects/${currentProjectId}/${item.id}/`, {  // ← ao_id 추가
            method: 'PUT',  // ← POST → PUT
            body: JSON.stringify(updateData),
        });

        if (saveResponse.ok) {
            updatedCount++;
        } else {
            const errorText = await saveResponse.text();  // ← 에러 텍스트 읽기
            console.warn('[WARN] Failed to save item:', item.id, errorText);
        }
    }
}
```

**동일한 패턴 적용**:
- PUT 메소드 사용
- URL에 `ao_id` 포함
- 최소한의 데이터만 전송
- 에러 텍스트 로깅

### 4. JavaScript - 자동 수량계산 수정

**파일**: `connections/static/connections/activity_object_manager.js`
**위치**: Line 2079-2098

**변경 전**:
```javascript
// AO.quantity 업데이트
ao.quantity = newQuantity;

// 서버에 저장
const saveResponse = await fetch(`/connections/api/activity-objects/${currentProjectId}/`, {
    method: 'POST',  // ← 문제
    body: JSON.stringify(ao),  // ← 전체 객체 전송
});

if (saveResponse.ok) {
    updatedCount++;
} else {
    console.warn(`[WARN][Auto Calc] Failed to save AO ${ao.id}`);
    errorCount++;
}
```

**변경 후**:
```javascript
// 서버에 저장
const updateData = {  // ← quantity만 전송
    quantity: newQuantity
};

const saveResponse = await fetch(`/connections/api/activity-objects/${currentProjectId}/${ao.id}/`, {  // ← ao_id 추가
    method: 'PUT',  // ← POST → PUT
    body: JSON.stringify(updateData),  // ← 최소 데이터만
});

if (saveResponse.ok) {
    updatedCount++;
} else {
    const errorText = await saveResponse.text();  // ← 에러 텍스트 읽기
    console.warn(`[WARN][Auto Calc] Failed to save AO ${ao.id}:`, errorText);
    errorCount++;
}
```

**특징**:
- 자동 수량계산은 `quantity` 필드만 업데이트
- `is_manual`, `manual_formula` 등은 변경하지 않음
- 더욱 간결한 요청 바디

## 수정 후 동작 흐름

### 수동 직접입력 (성공 시나리오)

```
1. 사용자: "수동 수량입력" 버튼 클릭
   ↓
2. 모달 오픈, 직접 입력 모드 선택, 값 12 입력
   ↓
3. "적용" 버튼 클릭
   ↓
4. JavaScript: updateData = {quantity: 12, is_manual: true, ...}
   ↓
5. PUT /api/activity-objects/{project_id}/{ao_id}/
   ↓
6. 서버: ao_id 확인 → ActivityObject 조회 → quantity 업데이트 → 저장
   ↓
7. 응답: 200 OK {"status": "success", ...}
   ↓
8. JavaScript: updatedCount++ → 테이블 새로고침 → 토스트 메시지
   ↓
9. 결과: "1개 항목의 수량이 업데이트되었습니다." ✅
```

### 수동 산식입력 (성공 시나리오)

```
1. 사용자: 산식 입력 모드 선택, "{CI.quantity} * 2.5" 입력
   ↓
2. "적용" 버튼 클릭
   ↓
3. JavaScript:
   - buildActivityObjectContext(item) 실행
   - evaluateQuantityFormula(formula, context) 실행
   - calculatedQuantity = 55 (예: CI.quantity=22, 22*2.5=55)
   ↓
4. updateData = {quantity: 55, manual_formula: "{CI.quantity} * 2.5", ...}
   ↓
5. PUT /api/activity-objects/{project_id}/{ao_id}/
   ↓
6. 서버: quantity=55, manual_formula 저장, quantity_expression JSON 저장
   ↓
7. 응답: 200 OK
   ↓
8. 결과: 테이블에 quantity=55 표시, 산식 저장됨 ✅
```

### 자동 수량계산 (성공 시나리오)

```
1. 사용자: "자동 수량계산" 버튼 클릭
   ↓
2. 확인 대화상자: "확인" 클릭
   ↓
3. JavaScript: 모든 ActivityObject 로드 (GET API)
   ↓
4. For each AO:
   ├─ Case 1 (자동): newQuantity = duration_per_unit * CI.quantity
   ├─ Case 2 (수동 직접): skip (건너뜀)
   └─ Case 3 (수동 산식): newQuantity = evaluateFormula()
   ↓
5. PUT /api/activity-objects/{project_id}/{ao_id}/
   - Body: {quantity: newQuantity}
   ↓
6. 서버: quantity만 업데이트, 다른 필드는 그대로
   ↓
7. 응답: 200 OK
   ↓
8. 결과: "45개 업데이트, 5개 건너뜀" 토스트 메시지 ✅
```

## 기술적 세부사항

### REST API 규약 준수

**HTTP 메소드 의미**:
- `GET`: 리소스 조회 (읽기 전용)
- `POST`: 새 리소스 생성
- `PUT`: 기존 리소스 업데이트 (전체 또는 부분)
- `DELETE`: 리소스 삭제

**이번 수정**:
- 기존 ActivityObject **업데이트** 작업
- `POST` (생성) → `PUT` (수정)으로 변경
- REST API 규약 준수

### URL 리소스 식별

**REST 원칙**:
- URL은 리소스를 고유하게 식별해야 함
- 컬렉션: `/api/activity-objects/{project_id}/`
- 개별 리소스: `/api/activity-objects/{project_id}/{ao_id}/`

**이번 수정**:
- 업데이트 작업은 **개별 리소스**를 대상으로 함
- URL에 `{ao_id}` 파라미터 추가
- 서버가 정확히 어떤 객체를 수정할지 알 수 있음

### 최소 권한 원칙 (Principle of Least Privilege)

**이전 방식**:
```javascript
body: JSON.stringify(item)  // 모든 필드 전송
// {
//   id, quantity, is_manual, manual_formula,
//   activity: {...}, cost_item: {...},
//   quantity_member: {...}, raw_data: {...}, ...
// }
```

**개선된 방식**:
```javascript
body: JSON.stringify(updateData)  // 필요한 필드만
// {
//   quantity: 12,
//   is_manual: true,
//   manual_formula: null,
//   quantity_expression: {...}
// }
```

**장점**:
1. **보안**: 의도하지 않은 필드 수정 방지
2. **성능**: 네트워크 대역폭 절약
3. **명확성**: 어떤 필드를 수정하는지 명확
4. **에러 감소**: 예상치 못한 필드로 인한 검증 오류 방지

### 에러 처리 개선

**이전**:
```javascript
console.warn('[WARN] Failed to save item:', item.id);
// → 어떤 에러인지 알 수 없음
```

**개선**:
```javascript
const errorText = await saveResponse.text();
console.warn('[WARN] Failed to save item:', item.id, errorText);
// → 서버 에러 메시지 출력
// 예: "수정 중 오류 발생: 'NoneType' object has no attribute 'quantity'"
```

**장점**:
- 디버깅 시간 단축
- 사용자 문제 보고 시 정확한 정보 제공
- 개발자가 근본 원인 빠르게 파악

### Django 서버 측 개선

**traceback 출력 추가**:
```python
except Exception as e:
    print(f"[ERROR][activity_objects_api] PUT Error: {e}")
    import traceback
    traceback.print_exc()  # ← 전체 스택 트레이스 출력
    return JsonResponse({'status': 'error', 'message': f'수정 중 오류 발생: {str(e)}'}, status=400)
```

**효과**:
- 서버 콘솔에서 에러 발생 지점 정확히 파악
- 파일명, 라인 번호, 호출 스택 모두 표시
- 빠른 문제 해결 가능

## 테스트 시나리오

### 1. 수동 직접입력 테스트

**절차**:
1. 액티비티 객체 탭 진입
2. 테이블에서 객체 1개 선택 (체크박스)
3. "수동 수량입력" 버튼 클릭
4. 직접 입력 모드 선택 (기본값)
5. 수량: `12` 입력
6. "적용" 버튼 클릭

**예상 결과** ✅:
- 콘솔: `[DEBUG][Manual AO Quantity] Direct mode: 12`
- 콘솔: `[DEBUG][activity_objects_api] PUT: Updated ActivityObject {ao_id}`
- 토스트: "1개 항목의 수량이 업데이트되었습니다."
- 테이블에서 해당 행의 `quantity` 값이 `12`로 표시
- **에러 없음**

### 2. 수동 산식입력 테스트

**절차**:
1. 액티비티 객체 1개 선택
2. "수동 수량입력" 버튼 클릭
3. 산식 입력 모드 선택
4. 산식: `{CI.quantity} * 2` 입력
5. "적용" 버튼 클릭

**예상 결과** ✅:
- 콘솔: `[DEBUG][Manual AO Quantity] Formula mode: {CI.quantity} * 2`
- 콘솔: `[DEBUG][evaluateQuantityFormula] Result: {계산값}`
- 콘솔: `[DEBUG][activity_objects_api] PUT: Updated ActivityObject {ao_id}`
- 토스트: "1개 항목의 수량이 업데이트되었습니다."
- 테이블에서 계산된 값 표시
- **에러 없음**

### 3. 자동 수량계산 테스트

**절차**:
1. 프로젝트에 액티비티 객체 여러 개 존재
2. "자동 수량계산" 버튼 클릭
3. 확인 대화상자에서 "확인" 클릭

**예상 결과** ✅:
- 콘솔: 각 AO에 대해 `[DEBUG][Auto Calc] Auto calculating for AO {id}: ...`
- 콘솔: 각 AO에 대해 `[DEBUG][activity_objects_api] PUT: Updated ActivityObject {id}`
- 토스트: "45개 항목이 재계산되었습니다. (5개 수동입력 유지)"
- 테이블 자동 새로고침
- 모든 자동 계산 객체의 수량이 업데이트됨
- **에러 없음**

### 4. 여러 객체 일괄 수정 테스트

**절차**:
1. 체크박스로 액티비티 객체 3개 선택
2. "수동 수량입력" 버튼 클릭
3. 직접 입력: `100` 입력
4. "적용" 버튼 클릭

**예상 결과** ✅:
- 콘솔: 3개의 PUT 요청 로그
- 토스트: "3개 항목의 수량이 업데이트되었습니다."
- 선택한 3개 모두 `quantity=100`으로 변경
- **에러 없음**

## 영향 범위

### 수정된 파일

1. **connections/views.py** (Line 6259-6260, 6275-6276)
   - `quantity_expression` 필드 지원 추가
   - `traceback` 에러 로깅 추가

2. **connections/static/connections/activity_object_manager.js**
   - `showManualAoQuantityInputModal()` - 직접 입력 (Line 1599-1623)
   - `showManualAoQuantityInputModal()` - 산식 입력 (Line 1641-1665)
   - `recalculateAllAoQuantities()` (Line 2079-2098)

### 영향받는 기능

- ✅ 액티비티 객체 수동 수량입력 (직접 모드)
- ✅ 액티비티 객체 수동 수량입력 (산식 모드)
- ✅ 액티비티 객체 자동 수량계산

### 호환성

- 기존 ActivityObject 데이터와 완전 호환
- 새로운 API 엔드포인트 사용 (PUT with ao_id)
- 기존 GET, POST, DELETE 동작에 영향 없음

## 추가 개선 사항

### 1. 일관된 에러 처리 패턴 적용

**현재 상태**:
- 세 곳(직접입력, 산식입력, 자동계산) 모두 동일한 에러 처리 패턴 적용
- `errorText` 읽기 및 로그 출력

**제안**:
- 다른 모듈(cost_item_manager.js, quantity_members_manager.js 등)에도 동일한 패턴 적용
- 전역 유틸리티 함수 생성 가능:
  ```javascript
  async function handleApiError(response, itemId) {
      const errorText = await response.text();
      console.warn(`[WARN] Failed to save item: ${itemId}`, errorText);
      return errorText;
  }
  ```

### 2. 배치 업데이트 API

**현재**:
- 여러 객체 수정 시 각각 개별 PUT 요청 (순차 처리)
- N개 객체 = N번의 HTTP 요청

**제안**:
- 배치 업데이트 API 추가
- 한 번의 요청으로 여러 객체 업데이트
- 예: `PUT /api/activity-objects/{project_id}/batch/`
  ```json
  {
    "updates": [
      {"id": "ao-1", "quantity": 12},
      {"id": "ao-2", "quantity": 15},
      {"id": "ao-3", "quantity": 20}
    ]
  }
  ```

**장점**:
- 네트워크 왕복 시간 감소
- 서버 부하 감소
- 트랜잭션 일관성 보장

### 3. 낙관적 UI 업데이트

**현재**:
- 서버 응답 후 테이블 새로고침
- 대기 시간 존재

**제안**:
- 서버 요청 전에 UI 먼저 업데이트 (낙관적 업데이트)
- 서버 응답 실패 시 롤백
- 사용자 경험 향상

### 4. 입력 검증 강화

**현재**:
- 클라이언트 측에서 기본적인 검증만 수행
- `isNaN()` 체크

**제안**:
- 서버 측 검증 추가:
  - `quantity`는 0 이상의 숫자
  - `manual_formula`는 최대 길이 제한
  - `quantity_expression`은 유효한 JSON
- 검증 실패 시 명확한 에러 메시지

## 학습 포인트

### REST API 설계 원칙

1. **HTTP 메소드 의미 준수**:
   - GET: 조회
   - POST: 생성
   - PUT/PATCH: 수정
   - DELETE: 삭제

2. **URL은 리소스 식별**:
   - 컬렉션: `/api/resources/`
   - 개별: `/api/resources/{id}/`

3. **최소한의 데이터 전송**:
   - 필요한 필드만 요청 바디에 포함
   - 보안과 성능 향상

### 디버깅 팁

1. **상세한 로그 출력**:
   - 클라이언트: 에러 텍스트 읽기
   - 서버: traceback 출력

2. **단계별 확인**:
   - 산식 평가 성공 → 로그 ✅
   - 네트워크 요청 전송 → 로그 ✅
   - 서버 응답 수신 → 에러 내용 로그 ✅

3. **재현 가능한 테스트**:
   - 사용자가 제공한 정확한 절차 따라하기
   - 콘솔 로그 전체 확인

## 관련 커밋

- 이전 작업: `e980962` - "Implement manual quantity input and auto quantity calculation for activity objects"
- 현재 작업: `e4e1cb6` - "Fix activity object manual quantity input and auto calculation API errors"
- 이전 작업: `088f6d6` - "Fix cost item view tab switching and activity view grouping"

## 참고 사항

- 이 수정으로 액티비티 객체 수량 관리 기능이 완전히 작동하게 되었습니다
- REST API 규약을 준수하도록 개선되었습니다
- 에러 처리가 강화되어 향후 디버깅이 용이합니다
- 서버 auto-reload가 정상 작동하여 코드 변경사항이 즉시 반영됩니다
- 브라우저 강제 새로고침 (Ctrl+Shift+R 또는 Cmd+Shift+R)으로 최신 JavaScript 파일을 로드하세요
