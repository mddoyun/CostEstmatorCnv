# 2025-10-28 작업 요약: 분할 객체 삭제 기능 및 is_active 필드 오류 수정

## 작업 개요
3D BIM 뷰어에서 분할 객체를 일괄 삭제하는 기능을 추가하고, 자동 업데이트 시 발생하던 is_active 필드 NOT NULL constraint 오류를 해결했습니다.

## 1. 모든 분할 객체 삭제 기능 구현

### 요구사항
- 테스트 목적으로 프로젝트의 모든 분할 객체를 삭제하는 기능 필요
- BIM 모델과 연관되지 않은 분할 객체 잔여물 정리

### 구현 내용

#### Backend API (connections/views.py:4447-4486)
```python
@require_http_methods(["DELETE"])
def delete_all_split_elements(request, project_id):
    """특정 프로젝트의 모든 분할 객체(SplitElement)를 삭제합니다."""
    try:
        project = get_object_or_404(Project, id=project_id)
        split_count = SplitElement.objects.filter(project=project).count()

        if split_count == 0:
            return JsonResponse({
                'status': 'success',
                'message': '삭제할 분할 객체가 없습니다.',
                'deleted_count': 0
            })

        # CASCADE로 연관된 QuantityMember, CostItem도 함께 삭제됨
        deleted_count, deleted_details = SplitElement.objects.filter(project=project).delete()

        return JsonResponse({
            'status': 'success',
            'message': f'{split_count}개의 분할 객체가 삭제되었습니다.',
            'deleted_count': split_count,
            'cascade_details': str(deleted_details)
        })
    except Exception as e:
        return JsonResponse({
            'status': 'error',
            'message': f'분할 객체 삭제 중 오류 발생: {str(e)}'
        }, status=500)
```

#### URL 라우팅 (connections/urls.py:130-132)
```python
path('api/projects/<uuid:project_id>/split-elements/delete-all/',
     views.delete_all_split_elements,
     name='delete_all_split_elements'),
```

#### Frontend UI (connections/templates/three_d_viewer.html:8)
```html
<button id="delete-all-splits-btn"
        style="background-color: #dc3545; color: white;">
    모든 분할 객체 삭제
</button>
```

#### JavaScript Handler (connections/static/connections/three_d_viewer.js:495-545)
```javascript
if (deleteAllSplitsBtn) {
    deleteAllSplitsBtn.onclick = async function() {
        if (!window.currentProjectId) {
            showToast('프로젝트를 먼저 선택하세요', 'warning');
            return;
        }

        const confirmed = confirm(
            '정말로 모든 분할 객체를 삭제하시겠습니까?\n\n' +
            '이 작업은 되돌릴 수 없으며, 연관된 산출부재와 산출항목도 함께 삭제됩니다.'
        );

        if (!confirmed) return;

        try {
            const response = await fetch(
                `/connections/api/projects/${window.currentProjectId}/split-elements/delete-all/`,
                {
                    method: 'DELETE',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': window.csrfToken
                    }
                }
            );

            const result = await response.json();

            if (result.status === 'success') {
                showToast(result.message, 'success');
                if (loadBtn) loadBtn.click(); // 지오메트리 새로고침
            } else {
                showToast(`삭제 실패: ${result.message}`, 'error');
            }
        } catch (error) {
            showToast('분할 객체 삭제 중 오류가 발생했습니다', 'error');
        }
    };
}
```

## 2. is_active 필드 NOT NULL Constraint 오류 수정

### 발생한 문제
사용자가 "일괄 자동 업데이트" 버튼 실행 시 다음 오류 발생:
```
NOT NULL constraint failed: connections_quantitymember.is_active
```

### 원인 분석
1. 데이터베이스에는 `is_active` 필드가 존재
2. Django 모델 정의에는 해당 필드가 누락
3. `update_or_create()`, `get_or_create()` 사용 시 필드를 명시하지 않아 INSERT 문에서 누락됨

### 해결 방법

#### Phase 1: views.py 수정
자동 생성 함수에서 is_active 필드를 명시적으로 설정:

**QuantityMember 생성 (views.py:858-866)**
```python
member, created = QuantityMember.objects.update_or_create(
    project=project,
    raw_element=element,
    classification_tag=tag,
    defaults={
        'name': f"{element.raw_data.get('Name', 'Unnamed')}_{tag.name}",
        'is_active': True  # ← 추가
    }
)
```

**CostItem 생성 (views.py:1417-1422)**
```python
item, created = CostItem.objects.get_or_create(
    project=project,
    quantity_member=member,
    cost_code=cost_code,
    defaults={'is_active': True}  # ← 추가
)
```

#### Phase 2: 모델 정의 수정
데이터베이스 스키마와 Django 모델을 동기화:

**QuantityMember 모델 (connections/models.py:357-360)**
```python
# Split-related fields
is_active = models.BooleanField(
    default=True,
    help_text="활성 상태 (분할된 경우 원본은 False)"
)
split_element = models.ForeignKey(
    'SplitElement',
    on_delete=models.CASCADE,
    related_name='quantity_members',
    null=True,
    blank=True,
    help_text="이 산출부재가 속한 분할 객체"
)
source_quantity_member = models.ForeignKey(
    'self',
    on_delete=models.SET_NULL,
    related_name='derived_members',
    null=True,
    blank=True,
    help_text="원본 산출부재 (분할 전)"
)
```

**CostItem 모델 (connections/models.py:395-399)**
```python
# Split-related fields
is_active = models.BooleanField(
    default=True,
    help_text="활성 상태 (분할된 경우 원본은 False)"
)
split_element = models.ForeignKey(
    'SplitElement',
    on_delete=models.CASCADE,
    related_name='cost_items',
    null=True,
    blank=True,
    help_text="이 산출항목이 속한 분할 객체"
)
source_cost_item = models.ForeignKey(
    'self',
    on_delete=models.SET_NULL,
    related_name='derived_items',
    null=True,
    blank=True,
    help_text="원본 산출항목 (분할 전)"
)
volume_ratio_applied = models.DecimalField(
    max_digits=10,
    decimal_places=6,
    null=True,
    blank=True,
    help_text="적용된 체적 비율 (quantity = 원본 quantity × volume_ratio)"
)
```

#### Phase 3: Migration 생성 및 적용
```bash
python manage.py makemigrations connections
# 생성된 마이그레이션: 0004_costitem_is_active_costitem_source_cost_item_and_more.py

python manage.py migrate connections
```

### 검증 결과
```python
# Django ORM이 필드를 정상적으로 인식
QuantityMember fields: is_active=True, split_element=True, source_quantity_member=True
CostItem fields: is_active=True, split_element=True, source_cost_item=True, volume_ratio_applied=True

# 데이터 조회 정상 동작
Active QuantityMembers: 5
Active CostItems: 10
```

## Git Commits

### Commit 1: Delete All Splits Feature
```
Add delete all split elements feature for testing

- Created DELETE API endpoint at /api/projects/<uuid>/split-elements/delete-all/
- Added red button in 3D viewer UI with confirmation dialog
- Implemented automatic geometry reload after deletion
- Added CASCADE deletion logging for debugging
```

### Commit 2: Fix is_active Constraint in Auto-create
```
Fix NOT NULL constraint error for is_active field in auto-create

- Add is_active=True to QuantityMember.update_or_create defaults
- Add is_active=True to CostItem.get_or_create defaults
- Fixes error: NOT NULL constraint failed: connections_quantitymember.is_active
```

### Commit 3: Add Missing Model Fields
```
Add missing split-related fields to QuantityMember and CostItem models

- Add is_active, split_element, source_quantity_member to QuantityMember
- Add is_active, split_element, source_cost_item, volume_ratio_applied to CostItem
- These fields already existed in the database but were missing from model definitions
- This fixes the 'NOT NULL constraint failed' error during auto-create operations
- Migration 0004 created and applied to sync Django ORM with database schema
```

## 영향받은 파일

### 수정된 파일
- `connections/views.py` - DELETE API 추가, is_active 필드 설정
- `connections/urls.py` - 새 엔드포인트 라우팅
- `connections/templates/three_d_viewer.html` - 삭제 버튼 추가
- `connections/static/connections/three_d_viewer.js` - 이벤트 핸들러 추가
- `connections/models.py` - 모델 필드 정의 추가

### 생성된 파일
- `connections/migrations/0004_costitem_is_active_costitem_source_cost_item_and_more.py`

## 기술적 세부사항

### CASCADE Deletion
SplitElement 삭제 시 자동으로 삭제되는 항목:
- 연관된 QuantityMember (split_element FK)
- 연관된 CostItem (split_element FK)
- 하위 분할 객체 (parent_split FK)

### is_active 필드의 역할
- `True`: 활성 상태, 실제 사용되는 데이터
- `False`: 비활성 상태, 분할 후 원본 데이터 (참조용)

### 데이터 무결성
- `source_quantity_member`, `source_cost_item`: 분할 전 원본 추적
- `volume_ratio_applied`: 체적 기반 수량 분배 비율 저장
- `split_element`: 어느 분할 객체에 속하는지 추적

## 사용자 피드백
사용자가 테스트를 위해 "일괄 자동 업데이트" 버튼을 실행했고, 발생한 오류를 보고했습니다. 오류의 원인을 분석하고 근본적인 해결책(모델 정의 수정)을 적용했습니다.

## 다음 단계
- 사용자가 "일괄 자동 업데이트" 버튼을 다시 테스트하여 오류가 해결되었는지 확인
- 분할 객체 삭제 기능을 사용한 테스트 진행
