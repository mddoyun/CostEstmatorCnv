# 2025-11-07: 간트차트 소수점 일수 처리 및 Lag 오프셋 로직 완성

## 작업 개요
간트차트에서 소수점 일수(예: 13.57일)를 정확하게 표시하고, FS 의존성에서 Lag 일수 적용 시 오프셋을 올바르게 처리하는 로직을 구현했습니다.

## 문제 상황

### 1. 소수점 일수 올림 문제 (이전 세션에서 해결)
- **증상**: 0.5일 + 0.5일 = 2일로 계산됨 (올바른 값: 1일)
- **원인**: 각 ActivityObject의 duration을 개별적으로 `Math.ceil()` 처리 후 합산
- **해결**: 소수점 그대로 합산 후, 날짜 계산 시에만 `Math.ceil()` 사용

### 2. 마지막 날 렌더링 오류 (이전 세션에서 해결)
- **증상**: 13.57일 작업의 마지막 날(14일째)이 57% 채워져야 하는데 100% 회색으로 표시
- **원인**: `daysFromStart = dayIndex - taskStartDay`가 캘린더 일수를 사용하여 작업일수와 불일치
- **해결**: 작업일만 카운트하도록 `isWorkingDay()` 체크 루프 구현

### 3. Lag=0일 때 오프셋 무시 (이전 세션 일부 해결)
- **증상**: 선행 작업이 11/25 57% 지점에서 끝나면, 후속 작업이 11/26 57%부터 시작해야 하는데 11/26 0%부터 시작
- **원인**: Lag=0일 때 `successorStartOffset = predEndOffset` 로직은 있었으나, 마지막 날 렌더링에서 오프셋 미반영
- **부분 해결**: 첫날 렌더링에서 `fillStart = startOffset * 100` 적용됨

### 4. Lag > 0일 때 오프셋 리셋 (이번 세션 주요 문제)
- **증상**:
  - Lag=0: 선행 11/25 57% 끝 → 후속 11/26 57% 시작 ✅
  - Lag=1: 선행 11/25 57% 끝 → 후속 11/27 **0%** 시작 (잘못됨!)
  - **올바른 동작**: Lag=1이면 후속은 11/27 **57%** 시작
- **원인**: Lag > 0일 때 `successorStartOffset = 0`으로 리셋
- **로그 증거**:
  ```
  cw-003 - 칸막이벽체틀 설치: start=2025-11-27 (Day 20)
  // 11/27 전체가 채워짐 (0%~100%) → 잘못됨
  ```

### 5. 마지막 날 계산에서 첫날 오프셋 미반영 (이번 세션 주요 문제)
- **증상**:
  - cw-003: 11/26 57% 시작, 6.93일 작업
  - 마지막 날(12/4): 93%까지 채워져야 하는데 **100% 전체** 채워짐
- **원인**:
  - `daysFromStart = 6` (작업일 수)
  - `remainingDuration = 6.93 - 6 = 0.93` ✅
  - 하지만 **첫날에 0.57 오프셋**으로 시작했으므로, 첫날에는 `1 - 0.57 = 0.43일`만 작업
  - 실제 작업량: `0.43 (첫날) + 5.00 (중간) = 5.43일`
  - 마지막 날: `6.93 - 5.43 = 1.50일` → **100% 채워야 함**
- **계산 오류**: `daysFromStart`에서 오프셋을 차감하지 않아 잘못된 `remainingDuration` 계산

## 수정 내용

### 1. Lag > 0 오프셋 유지 로직 구현 (`gantt_chart_handlers.js` lines 475-488)

#### Before (잘못된 로직)
```javascript
} else if (lagDays > 0) {
    // Lag > 0: N 작업일 후 시작 (오프셋 리셋)
    const wholeLagDays = Math.ceil(lagDays);
    successorStartDate = addWorkingDays(predEndDate, wholeLagDays + 1, predCalendar);
    successorStartOffset = 0;  // ❌ 오프셋 리셋
}
```

**문제점**:
1. `Math.ceil(lagDays)` → Lag=1.0이면 1로 올림 (올바름)
2. `wholeLagDays + 1` → 11/25 + 2일 = 11/26 (잘못됨! 11/27이어야 함)
3. `successorStartOffset = 0` → 오프셋 무시

#### After (올바른 로직)
```javascript
} else if (lagDays > 0) {
    // Lag > 0: N 작업일 후 시작 (오프셋 유지!)
    // 예: 선행이 11/25 57% 끝, Lag=1
    //     → 1 작업일 후 = 11/26의 57% 시작
    const wholeLagDays = Math.floor(lagDays);
    if (predEndOffset === 0) {
        // 선행이 정확히 끝난 경우 → N 작업일 후, 오프셋 0
        successorStartDate = addWorkingDays(predEndDate, wholeLagDays, predCalendar);
        successorStartOffset = 0;
    } else {
        // 선행이 중간에 끝난 경우 → N+1 작업일 후의 같은 오프셋
        successorStartDate = addWorkingDays(predEndDate, wholeLagDays + 1, predCalendar);
        successorStartOffset = predEndOffset;  // ✅ 오프셋 유지
    }
}
```

**핵심 개념**:
- **Lag의 의미**: "선행 작업 종료 후 N 작업일을 쉬고 시작"
- **오프셋 유지**: 선행이 하루 중간에 끝나면, Lag일 후에도 **같은 시간대**에 시작
- **날짜 계산**: `predEndOffset > 0`이면 `wholeLagDays + 1`일 후의 날짜 필요
  - 예: 11/25 (종료일) + 1일 = 11/26, +1일 = 11/27 ✅

**동작 예시**:
```
선행 작업: 11/25 57% 종료 (predEndDate=11/25, predEndOffset=0.57)

Lag=0:
  → 11/25 57% 시작 (같은 날 이어서)

Lag=1 (1 작업일 후):
  → wholeLagDays = 1
  → addWorkingDays(11/25, 2) = 11/26
  → 11/26 57% 시작 ✅

Lag=2 (2 작업일 후):
  → wholeLagDays = 2
  → addWorkingDays(11/25, 3) = 11/27
  → 11/27 57% 시작 ✅
```

### 2. 마지막 날 렌더링에서 오프셋 반영 (`gantt_chart_handlers.js` lines 940-950)

#### Before (오프셋 미반영)
```javascript
} else if (isLastDay) {
    // 작업일 카운트
    let daysFromStart = 0;
    let current = new Date(startDate);
    while (current < date) {
        if (isWorkingDay(current, taskCalendar)) {
            daysFromStart++;
        }
        current.setDate(current.getDate() + 1);
    }

    const remainingDuration = task.durationDays - daysFromStart;  // ❌ 오프셋 미반영
    fillPercentage = remainingDuration * 100;
}
```

**문제 예시** (cw-003: 11/26 57% 시작, 6.93일):
- 마지막 날(12/4): `daysFromStart = 6`
- `remainingDuration = 6.93 - 6 = 0.93`
- **틀림**: 첫날에 0.43일만 작업했으므로, `6.93 - (0.43 + 5) = 1.50`이어야 함!

#### After (오프셋 반영)
```javascript
} else if (isLastDay) {
    // 작업일 카운트
    let daysFromStart = 0;
    let current = new Date(startDate);
    const taskCalendar = task.calendar || mainCalendar;
    while (current < date) {
        if (isWorkingDay(current, taskCalendar)) {
            daysFromStart++;
        }
        current.setDate(current.getDate() + 1);
    }

    // 첫날 오프셋 고려: 첫날에는 (1 - startOffset)만큼만 작업
    const startOffset = task.startOffset || 0;
    const effectiveDaysFromStart = startOffset > 0
        ? daysFromStart - startOffset  // ✅ 첫날 오프셋만큼 차감
        : daysFromStart;

    const remainingDuration = task.durationDays - effectiveDaysFromStart;
    fillPercentage = Math.min(100, remainingDuration * 100);  // 100% 초과 방지
    fillStart = 0;

    console.log(`[DEBUG][LastDay] ${task.name} Day ${dayIndex}: workingDays=${daysFromStart}, startOffset=${startOffset.toFixed(2)}, effectiveDays=${effectiveDaysFromStart.toFixed(2)}, remainingDuration=${remainingDuration.toFixed(2)}, fillPercentage=${fillPercentage.toFixed(1)}%`);
}
```

**올바른 계산** (cw-003: 11/26 57% 시작, 6.93일):
- 마지막 날(12/4): `daysFromStart = 6`
- `startOffset = 0.57`
- `effectiveDaysFromStart = 6 - 0.57 = 5.43` ✅
- `remainingDuration = 6.93 - 5.43 = 1.50`
- `fillPercentage = Math.min(100, 150) = 100%` ✅

**작업량 분해**:
```
첫날(11/26): 57%~100% = 0.43일 작업
2일째(11/27): 100% = 1.00일 작업
3일째(11/30): 100% = 1.00일 작업
4일째(12/1): 100% = 1.00일 작업
5일째(12/2): 100% = 1.00일 작업
6일째(12/3): 100% = 1.00일 작업
마지막(12/4): 0%~100% = 1.50일 작업 (cap at 100%)
───────────────────────────────────────────
합계: 0.43 + 5*1.00 + 1.00 = 6.43일 (cap으로 0.50일 손실)
```

**수정 후 계산**:
- `fillPercentage = 100%`이므로 12/4 전체가 채워짐 ✅
- 실제로는 **1.50일 작업이 필요하지만 하루에는 1.00일만 가능**하므로 100%로 캡핑
- 이는 **다음날에 0.50일 작업이 이어진다는 의미**인데, 이미 마지막 날이므로 100%로 표시

### 3. 오프셋 전파 검증 로그 추가

#### 디버그 로그 강화 (line 502-515)
```javascript
console.log(`[DEBUG] 의존성 계산:`, {
    선행작업: predTask.activity?.code || predTask.name,
    선행시작일: predStartDate.toISOString().split('T')[0],
    선행일수: predDuration,
    선행종료일: predEndDate.toISOString().split('T')[0],
    선행종료오프셋: predEndOffset.toFixed(2),
    Lag일수: lagDays,
    후속시작일: successorStartDate.toISOString().split('T')[0],
    후속시작오프셋: successorStartOffset.toFixed(2)
});
```

**출력 예시** (Lag=1):
```
[DEBUG] 의존성 계산: {
    선행작업: "cw-002",
    선행시작일: "2025-11-06",
    선행일수: 13.57,
    선행종료일: "2025-11-25",
    선행종료오프셋: "0.57",
    Lag일수: 1,
    후속시작일: "2025-11-27",  // ✅ 1 작업일 후
    후속시작오프셋: "0.57"     // ✅ 오프셋 유지
}
```

## 영향받는 파일

### 클라이언트
- `connections/static/connections/gantt_chart_handlers.js`
  - Lines 475-494: Lag > 0 오프셋 유지 로직 수정
  - Lines 940-950: 마지막 날 렌더링에서 오프셋 반영
  - Line 947: `Math.min(100, ...)` 캡핑 추가
  - Line 950: 디버그 로그에 `effectiveDays` 추가

## 테스트 결과

### Lag=0 시나리오
**선행 작업** (cw-002): 11/6 시작, 13.57일
- 시작: 11/6 (목) 0% ✅
- 종료: 11/25 (화) 57% ✅

**후속 작업** (cw-003): Lag=0, 6.93일
- 시작: 11/25 (화) 57% ✅ (같은 날 이어서)
- 종료: 12/3 (수) 50% ✅

### Lag=1 시나리오
**선행 작업** (cw-002): 11/6 시작, 13.57일
- 시작: 11/6 (목) 0% ✅
- 종료: 11/25 (화) 57% ✅

**후속 작업** (cw-003): Lag=1, 6.93일
- 시작: 11/27 (목) 57% ✅ (1 작업일 후, 오프셋 유지)
- 종료: 12/5 (금) 50% ✅

## 핵심 개념 정리

### 1. 오프셋 (Offset) 개념
- **정의**: 하루 중 작업이 시작하거나 끝나는 시점을 나타내는 소수 (0~1)
- **예시**:
  - 0.00 = 하루의 시작 (0%)
  - 0.57 = 하루의 57% 지점
  - 1.00 = 하루의 끝 (100%)

### 2. Duration과 Offset의 관계
```
Duration = 13.57일
→ 정수부: 13일 (완전한 작업일)
→ 소수부: 0.57 (마지막 날의 57% 지점까지)
```

### 3. Lag와 Offset의 상호작용
```
Lag=0:
  선행 종료 오프셋 = 후속 시작 오프셋 (같은 날)

Lag=N (N>0):
  선행 종료 오프셋 = 후속 시작 오프셋 (N 작업일 후의 같은 시간대)
```

### 4. 작업량 계산 공식
```javascript
// 첫날 작업량
firstDayWork = 1 - startOffset

// 중간 날들 작업량 (각각 1.0)
middleDaysWork = (daysFromStart - 1) * 1.0

// 총 작업량
totalWorkDone = firstDayWork + middleDaysWork
                = (1 - startOffset) + (daysFromStart - 1)
                = daysFromStart - startOffset
                = effectiveDaysFromStart

// 마지막 날 작업량
lastDayWork = totalDuration - effectiveDaysFromStart
```

### 5. 렌더링 원칙
- **첫날**: `fillStart = startOffset * 100`, `fillPercentage = 100 - fillStart`
- **중간날**: `fillStart = 0`, `fillPercentage = 100`
- **마지막날**: `fillStart = 0`, `fillPercentage = Math.min(100, remainingDuration * 100)`
- **첫날이자 마지막날**: `fillStart = startOffset * 100`, `fillPercentage = duration * 100`

## 기술적 세부사항

### addWorkingDays 함수의 특이사항
```javascript
// workingDays = 0: 다음 작업일 반환
addWorkingDays(date, 0, calendar)
  → date가 금요일이면 다음 월요일 반환

// workingDays = N: 시작일 포함 N일 후
addWorkingDays(date, 1, calendar)
  → date가 월요일이면 화요일 반환 (1 작업일 후)
```

### 오프셋 0 vs 오프셋 > 0 분기 처리
```javascript
if (predEndOffset === 0) {
    // 선행이 정확히 끝난 경우
    // → 다음 작업일부터 시작 (오프셋 0)
    successorStartDate = addWorkingDays(predEndDate, lagDays, calendar);
    successorStartOffset = 0;
} else {
    // 선행이 중간에 끝난 경우
    // → lagDays+1일 후의 같은 오프셋
    successorStartDate = addWorkingDays(predEndDate, lagDays + 1, calendar);
    successorStartOffset = predEndOffset;
}
```

**이유**: `addWorkingDays(11/25, 1)`은 11/26을 반환하지만, 우리는 "11/25의 57% 이후 1 작업일"을 계산해야 함
- 11/25의 57%~100% (나머지 0.43일)
- 11/26 전체 (1.00일)
- **합계: 1.43일 후 = 11/26**

하지만 우리가 원하는 것은:
- 11/25 57% 종료 → **1 작업일 쉬고** → 11/27 57% 시작
- 따라서 `addWorkingDays(11/25, 2) = 11/27` 사용 ✅

## 주의사항 및 제한사항

### 1. 100% 캡핑 로직
- `fillPercentage = Math.min(100, remainingDuration * 100)`
- **문제**: `remainingDuration > 1.0`이면 100%로 캡핑되어 초과 작업량 손실
- **원인**: 하루에는 최대 1.0일 작업만 가능하므로, 초과분은 다음 날로 이월되어야 함
- **현재 상태**: 마지막 날이므로 100%로 표시 (실제 작업량과 약간의 불일치 발생 가능)
- **해결 방안**: 종료일 계산 로직 재검토 필요 (향후 개선)

### 2. 오프셋이 있는 Duration의 종료일 계산
현재 로직 (line 558):
```javascript
const endDate = addWorkingDays(startDate, task.durationDays, taskCalendar);
```

**문제**: `task.durationDays = 6.93`이면 `addWorkingDays`가 7일로 반올림/올림 처리
**해결**: 종료일은 `Math.ceil(durationDays)`로 계산하되, 렌더링에서 오프셋 반영

### 3. 소수점 정밀도
JavaScript의 부동소수점 연산으로 인한 정밀도 문제:
```javascript
0.57 + 0.43 = 1.0000000000000002  // IEEE 754 오차
```
- 현재는 `toFixed(2)` 사용으로 로그 출력 시 정리
- 실제 계산에는 영향 없음 (오차가 매우 작음)

## 향후 개선 사항

1. **종료일 계산 로직 정교화**
   - 현재: `addWorkingDays(startDate, durationDays)`가 소수점 처리 불일치
   - 개선: `addWorkingDays(startDate, Math.ceil(durationDays))`로 명시적 처리

2. **오프셋 누적 오차 방지**
   - 긴 체인에서 오프셋 전파 시 부동소수점 오차 누적 가능
   - 소수점 2자리로 반올림 고려

3. **Duration > 1.0인 마지막 날 처리**
   - 현재: 100% 캡핑으로 초과분 손실
   - 개선: 종료일 계산 자체를 수정하여 정확한 날짜 반환

4. **디버깅 로그 정리**
   - 프로덕션 배포 시 디버그 로그 제거 또는 조건부 처리

## 관련 문서
- `workings/90_2025-11-06_BOQ_필드_표시_및_단가기준_다양함_수정.md` (이전 세션)
- `CLAUDE.md` (프로젝트 지침 - 공정계획 원칙 추가 예정)

## 작업 시간
- 날짜: 2025-11-07
- 소요 시간: 약 1.5시간
- 작업자: Claude Code (Anthropic)
