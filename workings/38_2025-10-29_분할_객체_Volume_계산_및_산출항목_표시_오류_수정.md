# 38. 분할 객체 Volume 계산 및 산출항목 표시 오류 수정

**작성일**: 2025-10-29
**작업 범위**: 3D Viewer 분할 기능의 Volume 계산 정확도 개선 및 산출항목 표시 오류 해결

---

## 🎯 작업 개요

3D Viewer의 객체 분할(Split) 기능에서 발생한 두 가지 핵심 문제를 해결:
1. **Volume 계산 오류**: 분할된 객체를 재분할할 때 volume이 부정확하게 계산되는 문제
2. **산출항목 표시 오류**: 분할된 객체 선택 시 다른 객체의 산출항목까지 함께 표시되는 문제

---

## 📋 발견된 문제들

### 1. Volume 계산 오류 (World Space Geometry)

**증상**:
```
첫 번째 split: 1.575 → 0.7875 + 0.7875 (100% 보존) ✓
두 번째 split: 0.7875 → 0.525 + 0.525 (133% 증가!) ✗
```

**원인**:
- DB에서 로드된 split 객체는 world space 좌표계를 사용
- Volume 계산 함수가 origin (0,0,0) 기준으로 계산하여 원점에서 먼 geometry는 부정확
- 예:
  - Local space: (0, 0, 0) ~ (10.5, 0.05, 3) → 정확
  - World space: (-2.3, 1.5, 4.9) ~ (-1.4, 3, -5.4) → 부정확

**위치**: `connections/static/connections/three_d_viewer.js`

### 2. Capping 면의 Basis Vector 선택 오류

**원인**:
- planeNormal의 x 성분만 검사하여 tempVec 선택
- 특정 축 조합에서 수치적 불안정성 발생

```javascript
// 기존 (문제)
if (Math.abs(planeNormal.x) < 0.9) {
    tempVec = new THREE.Vector3(1, 0, 0);
} else {
    tempVec = new THREE.Vector3(0, 1, 0);
}
```

### 3. splitElementId 설정 오류

**증상**:
- Split 완료 후 객체 선택 시 "분할 정보 저장 중..." 메시지가 계속 표시
- `splitElementId: undefined` 상태 유지

**원인**:
- `split_saved` WebSocket 메시지 도착 시 scene에서 mesh를 찾지 못함
- Nested split 시 부모의 splitElementId가 복사되어 충돌

### 4. 산출항목 표시 필터링 오류

**증상**:
- 분할된 객체 선택 시 2개 항목만 표시되어야 하는데 4개 표시

**원인**:
- splitElementId가 설정되지 않아 원본 BIM 객체 기준으로 조회
- 동일한 raw_element_id를 가진 모든 QuantityMember 반환

---

## 🔧 해결 방법

### 1. Volume 계산 함수 개선

**파일**: `connections/static/connections/three_d_viewer.js:2823-2862`

**변경 사항**:
- Centroid(무게중심) 기준 상대 좌표 계산으로 변경
- 수치적 안정성 대폭 향상

```javascript
function calculateGeometryVolume(geometry, debug = false) {
    // Centroid 계산
    let cx = 0, cy = 0, cz = 0;
    const vertexCount = positions.length / 3;
    for (let i = 0; i < vertexCount; i++) {
        cx += positions[i * 3];
        cy += positions[i * 3 + 1];
        cz += positions[i * 3 + 2];
    }
    cx /= vertexCount;
    cy /= vertexCount;
    cz /= vertexCount;

    // Centroid 기준 상대 좌표로 volume 계산
    for (let i = 0; i < indices.length; i += 3) {
        const v0x = positions[i0 * 3] - cx;
        const v0y = positions[i0 * 3 + 1] - cy;
        const v0z = positions[i0 * 3 + 2] - cz;
        // ... 나머지 계산
    }
}
```

**효과**:
- World space geometry도 정확한 volume 계산 가능
- Volume 보존율 100% 달성

### 2. Capping Basis Vector 선택 개선

**파일**: `connections/static/connections/three_d_viewer.js:2527-2533`

**변경 사항**:
- planeNormal의 모든 성분(x, y, z) 검사
- 가장 직교하는 축을 tempVec으로 선택

```javascript
const absX = Math.abs(planeNormal.x);
const absY = Math.abs(planeNormal.y);
const absZ = Math.abs(planeNormal.z);

if (absX <= absY && absX <= absZ) {
    tempVec = new THREE.Vector3(1, 0, 0);
} else if (absY <= absX && absY <= absZ) {
    tempVec = new THREE.Vector3(0, 1, 0);
} else {
    tempVec = new THREE.Vector3(0, 0, 1);
}
```

**효과**:
- 모든 축 조합에서 수치적으로 안정적인 capping 면 생성

### 3. splitElementId 설정 메커니즘 개선

#### 3-1. Split 시 userData 초기화

**파일**: `connections/static/connections/three_d_viewer.js:2133, 2148`

```javascript
bottomMesh.userData = {
    ...selectedObject.userData,
    splitElementId: undefined,  // 새로운 split이므로 초기화
    splitPartType: 'bottom',
    parentSplitId: parentSplitId,
    // ...
};
```

#### 3-2. Pending Split Meshes Map 도입

**파일**: `connections/static/connections/three_d_viewer.js:2252-2264`

```javascript
// Split 완료 시 mesh들을 전역 Map에 저장
if (!window.pendingSplitMeshes) {
    window.pendingSplitMeshes = new Map();
}
const bottomKey = `${rawElementId}:${splitPartType}`;
window.pendingSplitMeshes.set(bottomKey, bottomMesh);
```

#### 3-3. 2단계 검색 전략

**파일**: `connections/static/connections/websocket.js:521-580`

```javascript
// 1차: pendingSplitMeshes Map에서 직접 검색 (100% 정확)
const meshKey = `${data.raw_element_id}:${data.split_part_type}`;
if (window.pendingSplitMeshes.has(meshKey)) {
    targetMesh = window.pendingSplitMeshes.get(meshKey);
    foundMesh = true;
}

// 2차: Scene traverse (fallback)
if (!foundMesh && window.scene) {
    window.scene.traverse((object) => {
        // ... 검색 로직
    });
}

// splitElementId 설정 및 Map에서 제거
if (foundMesh && targetMesh) {
    targetMesh.userData.splitElementId = data.split_id;
    window.pendingSplitMeshes.delete(meshKey);
}
```

**효과**:
- split_saved 메시지 도착 시 항상 올바른 mesh 찾기 가능
- splitElementId 즉시 설정되어 산출항목 표시 정확

### 4. 산출항목 표시 로직 강화

**파일**: `connections/static/connections/three_d_viewer.js:1530-1540`

```javascript
if (object.userData.splitElementId) {
    // splitElementId가 있으면 split 객체로 처리
    quantityMembers = findQuantityMembersBySplitElementId(object.userData.splitElementId);
} else if (object.userData.isSplitPart || object.userData.isSplitElement) {
    // split 객체인데 splitElementId가 없으면 대기
    tableContainer.innerHTML = '<p>분할 정보 저장 중... 잠시 후 다시 선택해주세요</p>';
    return;
} else {
    // 원본 BIM 객체
    quantityMembers = findQuantityMembersByRawElementId(bimObjectId);
}
```

**효과**:
- 선택된 객체의 항목만 정확하게 표시
- splitElementId 대기 중 명확한 피드백 제공

### 5. 함수 전역 노출 및 자동 갱신

**파일**: `connections/static/connections/three_d_viewer.js:1672-1675`

```javascript
window.displayQuantityMembersForObject = displayQuantityMembers;
window.displayCostItemsForObject = displayCostItems;
```

**파일**: `connections/static/connections/websocket.js:577-587`

```javascript
window.splitDataReloadTimer = setTimeout(() => {
    // 데이터 갱신
    window.loadQuantityMembersForViewer();
    window.loadCostItemsWithPrices();

    // 선택된 객체 표시 갱신
    if (window.selectedObject && window.scene) {
        window.displayQuantityMembersForObject(window.selectedObject);
        window.displayCostItemsForObject(window.selectedObject);
    }
}, 50);
```

**효과**:
- Split 완료 후 자동으로 산출항목 갱신
- 사용자가 다른 탭으로 이동하지 않아도 정확한 정보 표시

---

## 📊 수정된 파일 목록

1. **connections/static/connections/three_d_viewer.js**
   - `calculateGeometryVolume()`: Centroid 기준 계산 (2823-2862)
   - `splitGeometryByPlane()`: Basis vector 선택 개선 (2527-2533)
   - `splitSelectedObject()`: userData 초기화 (2133, 2148)
   - `splitSelectedObject()`: Pending meshes Map 저장 (2252-2264)
   - `displayCostItems()`: 로직 강화 및 디버깅 로그 추가 (1511-1553)
   - 함수 전역 노출 (1672-1675)

2. **connections/static/connections/websocket.js**
   - `split_saved` 핸들러: 2단계 검색 전략 (521-580)
   - Split 완료 후 자동 갱신 (577-587)

---

## ✅ 테스트 시나리오

### 시나리오 1: 연속 Split (Load 없이)
```
1. Load Geometry
2. 객체 선택 → Z축 50% split
3. 분할된 객체 선택 → 확인
   - Volume: 0.7875 (50%)
   - 산출항목: 2개 (선택된 객체만)
4. 다시 Z축 50% split
5. 분할된 객체 선택 → 확인
   - Volume: 0.39375 (25%)
   - 산출항목: 2개 (선택된 객체만)
```

### 시나리오 2: Load 후 Split
```
1. Load Geometry
2. 객체 선택 → split
3. Load Geometry (재로드)
4. Split된 객체 선택 → 다시 split
   - Volume 계산 정확
   - 산출항목 정확
```

### 예상 결과
- ✅ Volume 보존율: 100% (모든 단계)
- ✅ 산출항목 표시: 선택된 객체의 항목만 (2개)
- ✅ "분할 정보 저장 중..." 메시지: 표시되지 않음 (또는 0.1초 미만)
- ✅ 객체 겹침: 없음 (원본 객체 자동 숨김)

---

## 🔍 디버깅 로그 추가

### 콘솔 로그 예시
```javascript
[WebSocket] ========================================
[WebSocket] Split saved successfully: xxx-xxx-xxx
[WebSocket] ✓ Found mesh in pendingSplitMeshes Map
[WebSocket] ✓ Set splitElementId on mesh

[3D Viewer] ========================================
[3D Viewer] displayCostItems called
[3D Viewer] Object userData: {splitElementId: "xxx", ...}
[3D Viewer] ✓ Split object selected (splitElementId exists)
[3D Viewer] Found quantity members: 1
```

---

## 📝 주요 개념

### Centroid 기준 Volume 계산
- Signed volume formula는 origin을 기준으로 계산
- Geometry가 origin에서 멀수록 수치 오차 증가
- Centroid를 origin으로 사용하면 항상 정확

### Pending Split Meshes Map
- Split 직후 생성된 mesh의 직접 참조 저장
- Key: `"raw_element_id:split_part_type"`
- Value: Mesh object
- split_saved 시 100% 정확한 매칭 보장

### 2단계 검색 전략
1. **1차**: Map에서 직접 검색 (즉시, 정확)
2. **2차**: Scene traverse (fallback, 호환성)

---

## 🎓 배운 점

1. **수치적 안정성의 중요성**
   - 좌표계 선택이 계산 정확도에 큰 영향
   - 항상 상대 좌표로 계산하는 것이 안전

2. **비동기 처리의 복잡성**
   - WebSocket 메시지와 UI 상태 동기화 어려움
   - 직접 참조 저장으로 근본적 해결

3. **디버깅 로그의 가치**
   - 상세한 로그가 문제 진단 시간 단축
   - 사용자 제공 로그로 정확한 원인 파악 가능

---

## 📌 다음 작업 예정

현재 완료된 상태이며, 추가 테스트 필요 시:
1. 다양한 축 조합 테스트 (X, Y, Z)
2. 3단계 이상 중첩 split 테스트
3. 대용량 geometry split 성능 테스트

---

**작성자**: Claude Code
**검토**: 사용자 피드백 기반 수정 완료
