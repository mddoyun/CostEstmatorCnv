# 일괄 자동 업데이트 기능 개선: 6단계 → 13단계로 확장

**날짜**: 2025-11-05
**작업자**: Claude (AI Assistant)

## 개요
'일괄 자동 업데이트' 버튼의 기능을 6단계에서 13단계로 확장하고, "데이터 가져오기" 단계를 제외하여 이미 로드된 BIM 데이터를 기반으로 모든 후처리 작업을 순차적으로 실행하도록 개선했습니다.

## 주요 변경 사항

### 1. 단계 구성 변경
**파일**: `connections/static/connections/app.js`
**위치**: Lines 648-841

#### 기존 (6단계)
1. 데이터 가져오기 (WebSocket 대기)
2. 룰셋 일괄적용
3. 수량산출부재 자동 생성
4. 할당 룰셋 일괄 적용
5. 산출항목 자동 생성
6. 집계표 생성

#### 개선 후 (13단계)
1. **BIM원본데이터** - 룰셋 일괄적용
2. **수량산출부재** - 자동 생성 (분류 기준)
3. **수량산출부재** - 속성 룰셋 일괄 적용
4. **수량산출부재** - 할당 룰셋 일괄적용 (1차)
5. **수량산출부재** - 수동 수량 산출식 업데이트
6. **수량산출부재** - 할당 룰셋 일괄적용 (2차)
7. **코스트아이템** - 자동 생성(공사코드 기준)
8. **코스트아이템** - 룰셋수량계산 (전체)
9. **코스트아이템** - 산출식 업데이트
10. **코스트아이템** - 액티비티 룰셋 적용
11. **액티비티 객체** - 자동 생성(액티비티코드 기준)
12. **액티비티 객체** - 자동 수량계산
13. **액티비티 객체** - 산출식 업데이트

---

## 구현 세부 사항

### 1. 함수 시그니처 변경

**수정 전**:
```javascript
/**
 * 6단계의 자동화 프로세스를 순차적으로 실행하는 '일괄 자동 업데이트' 함수입니다.
 */
async function runBatchAutoUpdate() {
```

**수정 후**:
```javascript
/**
 * 13단계의 자동화 프로세스를 순차적으로 실행하는 '일괄 자동 업데이트' 함수입니다.
 * 데이터 가져오기 이후 단계만 실행합니다 (BIM 데이터는 이미 로드되어 있어야 함).
 */
async function runBatchAutoUpdate() {
```

---

### 2. 확인 메시지 개선

**수정 전**:
```javascript
if (!confirm(
    "정말로 모든 자동화 프로세스를 순차적으로 실행하시겠습니까?\n이 작업은 시간이 다소 소요될 수 있습니다."
)) {
    return;
}
```

**수정 후**:
```javascript
if (!confirm(
    "정말로 모든 자동화 프로세스를 순차적으로 실행하시겠습니까?\n" +
    "(데이터 가져오기는 제외되며, 이미 로드된 BIM 데이터를 기반으로 진행됩니다)\n\n" +
    "이 작업은 시간이 다소 소요될 수 있습니다."
)) {
    return;
}
```

---

### 3. 프로그레스바 업데이트

**수정 전**:
```javascript
const TOTAL_STEPS = 6;
```

**수정 후**:
```javascript
const TOTAL_STEPS = 13;
```

---

### 4. 데이터 가져오기 단계 제거

**제거된 코드** (Lines 679-708):
```javascript
// Promise를 사용하여 데이터 가져오기 완료를 기다리는 로직
const waitForDataFetch = () =>
    new Promise((resolve, reject) => {
        const listener = (event) => {
            const data = JSON.parse(event.data);
            if (data.type === "fetch_progress_complete") {
                frontendSocket.removeEventListener("message", listener);
                console.log("[DEBUG] (1/6) 데이터 가져오기 완료 신호 수신.");
                resolve();
            }
        };
        frontendSocket.addEventListener("message", listener);
        console.log("[DEBUG] (1/6) BIM 원본데이터 가져오기 시작...");
        showToast("1/6: BIM 원본데이터를 가져옵니다...", "info");
        fetchDataFromClient();
        setTimeout(() => {
            frontendSocket.removeEventListener("message", listener);
            reject(new Error("데이터 가져오기 시간 초과."));
        }, 300000);
    });

// 1. 데이터 가져오기 (완료될 때까지 대기)
await waitForDataFetch();
```

**이유**:
- 데이터 가져오기는 별도로 수동 실행 필요
- 일괄 자동 업데이트는 이미 로드된 데이터를 기반으로 후처리만 수행

---

### 5. 각 단계별 함수 호출

#### 단계 1: BIM원본데이터 - 룰셋 일괄적용
```javascript
console.log("[DEBUG] (1/13) BIM원본데이터 - 룰셋 일괄적용 시작...");
showToast("1/13: BIM원본데이터에 룰셋을 일괄 적용합니다...", "info");
await applyClassificationRules(true); // skipConfirmation = true
```
- **함수**: `applyClassificationRules(true)`
- **위치**: `ruleset_classification_handlers.js:173`
- **역할**: BIM 원본데이터에 분류 태그 할당

#### 단계 2: 수량산출부재 - 자동 생성
```javascript
await createAutoQuantityMembers(true); // skipConfirmation = true
```
- **함수**: `createAutoQuantityMembers(true)`
- **위치**: `quantity_members_manager.js:194`
- **역할**: 분류 태그 기준으로 QuantityMember 자동 생성

#### 단계 3: 수량산출부재 - 속성 룰셋 일괄 적용
```javascript
await applyPropertyRulesToAllQm();
```
- **함수**: `applyPropertyRulesToAllQm()`
- **위치**: `quantity_members_manager.js:2617`
- **역할**: 속성 매핑 룰셋 적용하여 QM에 사용자 정의 속성 추가

#### 단계 4: 수량산출부재 - 할당 룰셋 일괄적용 (1차)
```javascript
await applyAssignmentRules(true); // skipConfirmation = true
```
- **함수**: `applyAssignmentRules(true)`
- **위치**: `app.js:1036`
- **역할**: 일람부호(MemberMark), 공사코드(CostCode) 할당

#### 단계 5: 수량산출부재 - 수동 수량 산출식 업데이트
```javascript
await updateAllQmFormulas();
```
- **함수**: `updateAllQmFormulas()`
- **위치**: `quantity_members_manager.js:2968`
- **역할**: 수동 입력된 수량 산출식 재계산

#### 단계 6: 수량산출부재 - 할당 룰셋 일괄적용 (2차)
```javascript
await applyAssignmentRules(true); // skipConfirmation = true
```
- **함수**: `applyAssignmentRules(true)`
- **위치**: `app.js:1036`
- **역할**: 산출식 업데이트 후 재할당 (업데이트된 속성 기반)

#### 단계 7: 코스트아이템 - 자동 생성
```javascript
await createAutoCostItems(true); // skipConfirmation = true
```
- **함수**: `createAutoCostItems(true)`
- **위치**: `cost_item_manager.js:205`
- **역할**: 공사코드 기준으로 CostItem 자동 생성

#### 단계 8: 코스트아이템 - 룰셋수량계산 (전체)
```javascript
await applyCostItemQuantityRules(true); // skipConfirmation = true
```
- **함수**: `applyCostItemQuantityRules(true)`
- **위치**: `cost_item_manager.js:1627`
- **역할**: CostItem 수량 계산 룰셋 적용

#### 단계 9: 코스트아이템 - 산출식 업데이트
```javascript
await updateAllCiFormulas();
```
- **함수**: `updateAllCiFormulas()`
- **위치**: `cost_item_manager.js:2909`
- **역할**: CostItem의 수동 산출식 재계산

#### 단계 10: 코스트아이템 - 액티비티 룰셋 적용
```javascript
await applyCiActivityRules();
```
- **함수**: `applyCiActivityRules()`
- **위치**: `cost_item_manager.js:2708`
- **역할**: CostItem에 Activity 할당

#### 단계 11: 액티비티 객체 - 자동 생성
```javascript
await createActivityObjectsAuto();
```
- **함수**: `createActivityObjectsAuto()`
- **위치**: `activity_object_manager.js:179`
- **역할**: 액티비티코드 기준으로 ActivityObject 자동 생성

#### 단계 12: 액티비티 객체 - 자동 수량계산
```javascript
await recalculateAllAoQuantities();
```
- **함수**: `recalculateAllAoQuantities()`
- **위치**: `activity_object_manager.js:2020`
- **역할**: ActivityObject의 수량 자동 계산

#### 단계 13: 액티비티 객체 - 산출식 업데이트
```javascript
await updateAllAoFormulas();
```
- **함수**: `updateAllAoFormulas()`
- **위치**: `activity_object_manager.js:2574`
- **역할**: ActivityObject의 수동 산출식 재계산

---

## 함수 재사용 원칙

이 구현은 **Anti-Hardcoding Policy**를 준수합니다:

### 원칙
✅ **새 함수를 만들지 않음** - 기존 버튼 이벤트 함수를 직접 호출
✅ **단일 진실 공급원 유지** - 각 기능의 로직은 한 곳에만 존재
✅ **유지보수성 향상** - 버튼 함수 수정 시 일괄 업데이트도 자동 반영

### 구현 방식
```javascript
// ❌ 나쁜 예: 새로운 함수 생성 또는 로직 복사
async function batchStep1() {
    // applyClassificationRules 로직을 복사...
}

// ✅ 좋은 예: 기존 함수 직접 호출
await applyClassificationRules(true);
```

---

## 순차 실행 보장

### await 사용
각 단계는 **async/await** 패턴을 사용하여 앞 단계가 완전히 완료된 후 다음 단계 실행:

```javascript
try {
    // 단계 1 완료 대기
    await applyClassificationRules(true);

    // 단계 1이 완료된 후에만 단계 2 실행
    await createAutoQuantityMembers(true);

    // 단계 2가 완료된 후에만 단계 3 실행
    await applyPropertyRulesToAllQm();

    // ... 계속
} catch (error) {
    console.error("[ERROR] 일괄 자동 업데이트 중 오류 발생:", error);
    showToast(`오류 발생: ${error.message}`, "error", 5000);
}
```

### 단계 간 지연
각 단계 사이에 1초 지연을 추가하여 UI 업데이트 및 사용자 피드백 제공:

```javascript
await new Promise((resolve) => setTimeout(resolve, 1000));
```

---

## 사용자 피드백

### 프로그레스바 업데이트
```javascript
if (progressBar && progressStatus) {
    progressBar.value = 1;
    progressStatus.textContent = `1/${TOTAL_STEPS} 완료`;
}
```

### Toast 메시지
각 단계마다 시작/완료 메시지 표시:
```javascript
// 시작 메시지
showToast("1/13: BIM원본데이터에 룰셋을 일괄 적용합니다...", "info");

// 완료 메시지
showToast("✅ (1/13) BIM원본데이터 룰셋 일괄적용 완료.", "success");
```

---

## 에러 처리

### Try-Catch 블록
전체 프로세스를 try-catch로 감싸서 안정성 확보:

```javascript
try {
    // 13단계 실행...
} catch (error) {
    console.error("[ERROR] 일괄 자동 업데이트 중 오류 발생:", error);
    showToast(`오류 발생: ${error.message}`, "error", 5000);

    // 에러 발생 시 프로그레스바 리셋
    if (progressBar && progressStatus) {
        progressBar.value = 0;
        progressStatus.textContent = '';
    }
} finally {
    // 항상 프로젝트 선택 가능하도록 복원
    const projectSelector = document.getElementById("project-selector");
    if (projectSelector) projectSelector.disabled = false;
}
```

---

## 테스트 시나리오

### 정상 시나리오
1. 프로젝트 선택
2. BIM 데이터 로드 완료
3. "일괄 자동 업데이트" 버튼 클릭
4. 확인 다이얼로그 승인
5. 13단계 순차 실행 (각 단계마다 Toast 표시)
6. 프로그레스바가 0/13 → 13/13으로 진행
7. 완료 메시지 표시

### 에러 시나리오
1. 중간 단계에서 에러 발생
2. 콘솔에 에러 로그 출력
3. 사용자에게 에러 Toast 표시
4. 프로그레스바 리셋
5. 프로젝트 선택 활성화

### 사전 조건 미충족
1. BIM 데이터 미로드 상태
2. 일부 단계에서 데이터 부족으로 에러 발생 가능
3. 사용자는 먼저 BIM 데이터를 로드해야 함

---

## 성능 고려사항

### 단계별 예상 시간
- 단계 1-2: 5-10초 (BIM 데이터 양에 따라)
- 단계 3-6: 각 1-5초
- 단계 7-10: 각 1-3초
- 단계 11-13: 각 1-2초

**총 예상 시간**: 약 20-50초 (프로젝트 규모에 따라)

### 최적화 포인트
- 각 함수는 이미 최적화되어 있음
- 병렬 처리는 하지 않음 (데이터 의존성 때문)
- 불필요한 UI 업데이트 최소화

---

## 파일 변경 목록

### 수정된 파일
1. **connections/static/connections/app.js** (Lines 648-841)
   - `runBatchAutoUpdate()` 함수 완전 재작성
   - 6단계 → 13단계로 확장
   - 데이터 가져오기 단계 제거
   - 함수 재사용 방식으로 구현

---

## 관련 함수 참조

| # | 함수 이름 | 파일 | Line | 역할 |
|---|---|---|---|---|
| 1 | `applyClassificationRules()` | ruleset_classification_handlers.js | 173 | BIM 분류 태그 할당 |
| 2 | `createAutoQuantityMembers()` | quantity_members_manager.js | 194 | QM 자동 생성 |
| 3 | `applyPropertyRulesToAllQm()` | quantity_members_manager.js | 2617 | QM 속성 룰셋 적용 |
| 4 | `applyAssignmentRules()` | app.js | 1036 | 할당 룰셋 적용 |
| 5 | `updateAllQmFormulas()` | quantity_members_manager.js | 2968 | QM 산출식 업데이트 |
| 6 | `createAutoCostItems()` | cost_item_manager.js | 205 | CI 자동 생성 |
| 7 | `applyCostItemQuantityRules()` | cost_item_manager.js | 1627 | CI 수량 계산 |
| 8 | `updateAllCiFormulas()` | cost_item_manager.js | 2909 | CI 산출식 업데이트 |
| 9 | `applyCiActivityRules()` | cost_item_manager.js | 2708 | CI 액티비티 할당 |
| 10 | `createActivityObjectsAuto()` | activity_object_manager.js | 179 | AO 자동 생성 |
| 11 | `recalculateAllAoQuantities()` | activity_object_manager.js | 2020 | AO 수량 계산 |
| 12 | `updateAllAoFormulas()` | activity_object_manager.js | 2574 | AO 산출식 업데이트 |

---

## 향후 개선 사항

1. **선택적 단계 실행**: 체크박스로 실행할 단계 선택 가능
2. **배치 처리 최적화**: 대량 데이터 처리 시 청크 단위로 분할
3. **진행 상황 저장**: 중단 후 재개 가능하도록 진행 상황 저장
4. **병렬 처리**: 독립적인 단계는 병렬 실행 (데이터 의존성 분석 필요)
5. **스킵 가능한 단계**: 이미 완료된 단계는 자동 스킵

---

## 관련 이슈
- 일괄 자동 업데이트 기능 개선 요청
- 데이터 가져오기 분리
- 단계별 세분화

---

## 참고
- 이전 작업: `77_2025-11-05_ActivityObject_수동수량입력_및_산출식_업데이트_완성.md`
- 관련 문서: `CLAUDE.md` (Code Reusability and Anti-Hardcoding Policy 섹션)
