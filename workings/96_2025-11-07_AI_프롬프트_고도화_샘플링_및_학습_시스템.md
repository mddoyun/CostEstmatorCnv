# 2025-11-07: AI 프롬프트 시스템 고도화 - 샘플링 및 학습 시스템

## 작업 개요
AI 프롬프트 기능을 고도화하여 다음 3가지 액션을 지원하도록 개선:
1. **Select**: 3D 뷰포트에서 객체 선택
2. **Answer**: 질문에 대한 정리된 텍스트 답변
3. **Section**: 단면상자 생성 및 표시

## 핵심 요구사항

### 1. 전체 데이터 분석 우선
- AI가 액션을 수행하기 전에 **모든 연결된 객체 정보**를 분석해야 함
- Property Inheritance Chain 전체를 고려:
  ```
  BIM RawElement → QuantityMember → MemberMark → CostItem → CostCode → ActivityObject → Activity
  ```

### 2. 종합적 판단
- 단일 속성이 아닌 **전체 컨텍스트**로 판단
- 예: IfcWall이지만 QM이 "구조기초"로 분류되면 벽이 아님
- 예: "조적공사" 객체는 BIM + QM + CI + Activity 전체에서 "조적" 관련 정보 확인

### 3. 샘플링을 통한 성능 최적화
- 모든 객체 데이터를 AI에게 전송하면 프롬프트가 너무 커짐
- 대표 샘플을 선택하여 AI가 패턴을 학습하도록 함

### 4. 학습 가능한 우선순위 시스템
- 속성별 우선순위를 설정하고 쿼리 결과에 따라 조정
- 성공적인 쿼리의 경우 사용된 속성 우선순위 증가
- 실패한 쿼리의 경우 우선순위 감소

## 시스템 아키텍처

### 전체 파이프라인 (5단계)

```
사용자 쿼리 입력
  ↓
[Step 1] AI가 필요한 속성 결정
  - Ollama에게 쿼리 분석 요청
  - 어떤 인덱스를 사용할지 결정
  - primary/secondary 속성 분리
  ↓
[Step 2] 인덱스로 후보 객체 검색
  - AIIndexBuilder 사용
  - 빠른 검색 (Map 기반)
  - primary + secondary 속성으로 후보 수집
  ↓
[Step 3] 대표 샘플 선택
  - 후보가 너무 많으면 샘플링
  - 다양한 분류 태그를 가진 객체 골고루 선택
  - 기본: 최대 10개 샘플
  ↓
[Step 4] AI가 샘플 분석하여 필터 규칙 생성
  - Ollama에게 샘플 전송
  - 패턴 학습 → 필터 규칙 생성
  - JSON 형식: { attribute_path, operator, value }
  ↓
[Step 5] 필터 규칙 적용하여 최종 선택
  - 모든 후보에 규칙 적용
  - 조건 만족하는 객체만 선택
  - 3D 뷰포트에서 선택 실행
  ↓
결과 표시 및 학습
  - 선택 이유 로그 출력
  - 쿼리 히스토리 저장
  - 속성 우선순위 업데이트
```

## 구현 파일

### 1. `ai_index_builder.js` - 인덱싱 시스템

**목적**: 빠른 객체 검색을 위한 인덱스 구축

**주요 인덱스**:
- `byIfcClass`: IFC 클래스별 (IfcWall, IfcSlab 등)
- `byCategory`: Revit 카테고리별 (Walls, Floors 등)
- `byFamily`: Revit 패밀리별
- `byType`: Revit 타입별
- `byClassificationTag`: QM 분류 태그별 (가장 중요!)
- `byMemberMark`: 일람부호별
- `byCostCode`: 공사코드별
- `byCostCodeName`: 공사코드 이름별
- `byActivity`: 공정 이름별
- `byActivityCode`: 공정 코드별
- `byKeyword`: 전체 키워드 검색 (모든 텍스트 포함)

**주요 메서드**:
```javascript
// 전체 인덱스 빌드
await aiIndexBuilder.buildAll();

// 인덱스 검색
const ids = aiIndexBuilder.search('byClassificationTag', '건축_골조_벽_RC');

// 키워드 검색 (부분 일치)
const ids = aiIndexBuilder.searchByKeyword('조적');

// 여러 조건 검색 (AND)
const ids = aiIndexBuilder.searchMultiple([
    { index: 'byIfcClass', key: 'IfcWall' },
    { index: 'byClassificationTag', key: '벽' }
]);
```

**자동 인덱싱**:
- `revit-data-loaded` 이벤트 발생 시 자동으로 인덱스 빌드
- 데이터 로드 후 즉시 검색 가능

**성능**:
- Map 기반 O(1) 검색
- 수천 개 객체도 빠른 검색 (< 10ms)

### 2. `ai_query_processor.js` - 쿼리 처리 시스템

**목적**: 샘플링, AI 분석, 필터링 처리

**Step 1: 속성 결정**
```javascript
const attributeSpec = await processor.determineRelevantAttributes(userQuery);
// 반환:
// {
//     primary_attributes: [
//         { index: 'byClassificationTag', keywords: ['벽'], reason: '...' }
//     ],
//     secondary_attributes: [...],
//     intent: 'select',
//     analysis: '...'
// }
```

**Step 2: 후보 검색**
```javascript
const candidateIds = await processor.findCandidateObjects(attributeSpec);
// primary + secondary 속성으로 후보 수집
```

**Step 3: 샘플링**
```javascript
const sampleIds = processor.selectRepresentativeSamples(candidateIds);
// 대표성 있는 샘플 선택 (최대 10개)
// 다양한 classification_tag를 가진 객체 골고루 선택
```

**Step 4: AI 분석**
```javascript
const filterSpec = await processor.analyzeSamplesAndDecide(userQuery, sampleIds, candidateIds);
// 반환:
// {
//     filter_rules: [
//         {
//             attribute_path: 'QM.classification_tag',
//             operator: 'contains',
//             value: '벽',
//             reason: '...'
//         }
//     ],
//     confidence: 0.9,
//     analysis: '...'
// }
```

**Step 5: 필터링**
```javascript
const results = processor.applyFilterRules(candidateIds, filterSpec.filter_rules);
// 모든 후보에 필터 규칙 적용
// 조건 만족하는 객체만 반환
```

**학습 시스템**:
```javascript
// 속성 우선순위 (로컬 스토리지 저장)
attributePriorities = {
    'byClassificationTag': 9,  // 가장 높음
    'byCostCodeName': 8,
    'byActivity': 7,
    // ...
}

// 성공 시 우선순위 증가
processor.updatePriorities(usedAttributes, success=true);

// 실패 시 우선순위 감소
processor.updatePriorities(usedAttributes, success=false);

// 쿼리 히스토리 저장
processor.recordQuery(query, resultCount, confidence);
```

**객체 데이터 수집**:
```javascript
const data = processor.collectObjectData(rawElementId);
// 반환:
// {
//     id: '...',
//     BIM: { raw_data },
//     QM: [{ classification_tag, quantity, ... }],
//     MM: [{ name, ... }],
//     CI: [{ cost_codes, ... }],
//     CC: [{ code, name, ... }],
//     AO: [{ start_date, end_date, ... }],
//     AC: [{ code, name, ... }]
// }
```

### 3. `ai_select_handler.js` - 선택 액션 핸들러

**목적**: 5단계 파이프라인 실행 및 3D 뷰포트 선택

**사용법**:
```javascript
await handleAiSelectCommand("벽을 선택해줘");
await handleAiSelectCommand("조적공사때 진행해야하는 객체를 다 선택해줘");
```

**실행 플로우**:
1. 인덱스 확인 및 빌드 (필요 시)
2. 5단계 파이프라인 실행
3. 3D 뷰포트에서 선택 (`viewer.selectObjectsByIds()`)
4. 토스트 메시지로 결과 표시
5. 선택 이유 로그 출력
6. 학습 데이터 저장

**기존 chat_command_handler 통합**:
```javascript
// "선택" 키워드가 포함되면 AI 선택 핸들러 사용
if (command.includes('선택') || command.includes('보여줘') || command.includes('찾아줘')) {
    await handleAiSelectCommand(command);
} else {
    // 기존 핸들러 사용
    await originalHandler(command);
}
```

## 샘플링 전략

### 대표성 있는 샘플 선택

**문제**:
- 후보 객체가 수천 개일 경우 모두 AI에게 전송하면 프롬프트가 너무 커짐
- Ollama API에는 토큰 제한이 있음

**해결**:
- 최대 샘플 개수: 10개 (설정 가능)
- 다양한 `classification_tag`를 가진 객체 골고루 선택
- 각 그룹에서 균등하게 샘플링

**예시**:
```
후보 1000개:
- "건축_골조_벽_RC": 500개
- "건축_골조_벽_벽돌": 300개
- "건축_골조_기초_RC": 200개

샘플 10개 선택:
- "건축_골조_벽_RC"에서 4개
- "건축_골조_벽_벽돌"에서 3개
- "건축_골조_기초_RC"에서 3개
```

**코드**:
```javascript
selectRepresentativeSamples(candidateIds) {
    // classification_tag별로 그룹핑
    const tagGroups = new Map();

    candidateIds.forEach(id => {
        const qms = loadedQuantityMembers.filter(qm => qm.raw_element_id === id);
        qms.forEach(qm => {
            const tag = qm.classification_tag || 'unclassified';
            if (!tagGroups.has(tag)) {
                tagGroups.set(tag, []);
            }
            tagGroups.get(tag).push(id);
        });
    });

    // 각 그룹에서 골고루 샘플링
    const samplesPerGroup = Math.ceil(maxSampleSize / tagGroups.size);
    const samples = [];

    tagGroups.forEach((ids, tag) => {
        const groupSamples = ids.slice(0, samplesPerGroup);
        samples.push(...groupSamples);
    });

    return samples.slice(0, maxSampleSize);
}
```

## AI 프롬프트 설계

### Step 1 프롬프트: 속성 결정

```
다음 사용자 질문을 분석하여, 어떤 BIM 객체 속성들을 확인해야 하는지 결정하세요.

사용자 질문: "벽을 선택해줘"

사용 가능한 속성 인덱스:
- byIfcClass: IFC 클래스
- byCategory: Revit 카테고리
- byClassificationTag: 물량 분류 태그 (가장 중요!)
- byCostCodeName: 공사코드 이름
- byActivity: 공정 이름
- ... (전체 리스트)

JSON 형식으로 반환하세요:
{
    "primary_attributes": [
        { "index": "byClassificationTag", "keywords": ["벽"], "reason": "..." }
    ],
    "secondary_attributes": [...],
    "intent": "select"
}
```

**AI 응답 예시**:
```json
{
    "primary_attributes": [
        { "index": "byClassificationTag", "keywords": ["벽"], "reason": "분류 태그가 가장 정확" },
        { "index": "byIfcClass", "keywords": ["IfcWall"], "reason": "IFC 클래스 확인" }
    ],
    "secondary_attributes": [
        { "index": "byCategory", "keywords": ["Walls"], "reason": "카테고리로도 확인" }
    ],
    "intent": "select"
}
```

### Step 4 프롬프트: 필터 규칙 생성

```
사용자 질문: "벽을 선택해줘"

다음은 후보 객체 중 대표 샘플입니다 (전체 500개 중 10개):

=== 샘플 #1 ===
ID: abc-123
BIM 속성:
  - IfcClass: IfcWall
  - Category: Walls
  - Family: Basic Wall
QM 분류:
  - classification_tag: 건축_골조_벽_RC
  - quantity: 25.5
공사코드:
  - 콘크리트공사

=== 샘플 #2 ===
ID: def-456
BIM 속성:
  - IfcClass: IfcWall
  - Category: Walls
QM 분류:
  - classification_tag: 건축_골조_기초_RC
공사코드:
  - 기초공사

... (8개 더)

위 샘플을 분석하여, 사용자 질문에 해당하는 객체를 판단하는 "필터 규칙"을 만드세요.

JSON 형식으로 반환:
{
    "filter_rules": [
        {
            "attribute_path": "QM.classification_tag",
            "operator": "contains",
            "value": "벽",
            "reason": "분류 태그에 '벽'이 포함되어야 함"
        },
        {
            "attribute_path": "QM.classification_tag",
            "operator": "not_contains",
            "value": "기초",
            "reason": "기초로 재분류된 것은 제외"
        }
    ],
    "confidence": 0.9
}
```

**AI 응답 예시**:
```json
{
    "filter_rules": [
        {
            "attribute_path": "QM.classification_tag",
            "operator": "contains",
            "value": "벽",
            "reason": "샘플 #1은 벽이고 #2는 기초. classification_tag에 '벽' 포함 여부로 구분"
        },
        {
            "attribute_path": "QM.classification_tag",
            "operator": "not_contains",
            "value": "기초",
            "reason": "IfcWall이지만 기초로 재분류된 경우 제외"
        }
    ],
    "expected_match_count": "250개 정도",
    "confidence": 0.95,
    "analysis": "샘플 분석 결과 QM 분류 태그가 가장 신뢰할 수 있는 구분 기준"
}
```

## 필터 규칙 적용

### 지원되는 연산자

- `equals`: 정확히 일치
- `contains`: 부분 문자열 포함
- `startsWith`: ~로 시작
- `endsWith`: ~로 끝남
- `not_contains`: 포함하지 않음

### 적용 로직

```javascript
applyFilterRules(candidateIds, filterRules) {
    const results = [];

    for (const id of candidateIds) {
        const data = collectObjectData(id);
        let matches = true;

        for (const rule of filterRules) {
            // 경로로 값 가져오기 (예: "QM.classification_tag")
            const value = getValueByPath(data, rule.attribute_path);

            // 규칙 평가
            const ruleMatch = evaluateRule(value, rule.operator, rule.value);

            if (!ruleMatch) {
                matches = false;
                break;  // AND 조건: 하나라도 실패하면 전체 실패
            }
        }

        if (matches) {
            results.push({ id, reasons: [...] });
        }
    }

    return results;
}
```

### 경로 파싱

```javascript
getValueByPath(data, path) {
    // "QM.classification_tag" → data.QM[0].classification_tag
    // "BIM.Attributes.IfcClass" → data.BIM["Attributes.IfcClass"]

    const parts = path.split('.');
    let current = data;

    for (const part of parts) {
        if (current == null) return null;

        // 배열이면 첫 번째 요소 사용
        if (Array.isArray(current)) {
            current = current[0];
        }

        current = current[part];
    }

    return current;
}
```

## 학습 시스템

### 속성 우선순위

**초기값** (1-10):
```javascript
{
    'byClassificationTag': 9,    // QM 분류가 가장 중요
    'byCostCodeName': 8,
    'byActivity': 7,
    'byIfcClass': 6,
    'byCategory': 5,
    'byMemberMark': 4,
    'byFamily': 3,
    'byType': 2,
    'byCostCode': 1,
    'byActivityCode': 1
}
```

**업데이트 로직**:
```javascript
updatePriorities(usedAttributes, success) {
    if (success) {
        // 성공 시 우선순위 +0.1 (최대 10)
        usedAttributes.forEach(attr => {
            this.attributePriorities[attr.index] = Math.min(
                10,
                this.attributePriorities[attr.index] + 0.1
            );
        });
    } else {
        // 실패 시 우선순위 -0.1 (최소 1)
        usedAttributes.forEach(attr => {
            this.attributePriorities[attr.index] = Math.max(
                1,
                this.attributePriorities[attr.index] - 0.1
            );
        });
    }

    // 로컬 스토리지에 저장
    this.savePriorities();
}
```

**활용**:
- 향후 Step 1에서 속성 결정 시 우선순위 높은 속성을 먼저 고려
- AI에게 우선순위 정보 전달하여 더 정확한 판단 유도

### 쿼리 히스토리

**저장 내용**:
```javascript
{
    query: "벽을 선택해줘",
    timestamp: 1699350000000,
    resultCount: 250,
    confidence: 0.95
}
```

**활용**:
- 최근 100개 쿼리 저장 (로컬 스토리지)
- 통계 분석 가능
- 자주 사용되는 쿼리 패턴 파악

## 성능 최적화

### 인덱싱
- Map 기반 O(1) 검색
- 수천 개 객체도 < 10ms 검색

### 샘플링
- 최대 10개 샘플만 AI에게 전송
- 프롬프트 크기 제한
- 대표성 있는 샘플 선택으로 정확도 유지

### 캐싱
- 인덱스는 한 번만 빌드
- `revit-data-loaded` 이벤트 시 자동 갱신
- 로컬 스토리지에 우선순위/히스토리 저장

## 사용 예시

### 예시 1: 벽 선택

**사용자 쿼리**: "벽을 선택해줘"

**실행 과정**:
```
[Step 1] AI 속성 결정
→ primary: byClassificationTag["벽"], byIfcClass["IfcWall"]
→ secondary: byCategory["Walls"]

[Step 2] 후보 검색
→ byClassificationTag["벽"]: 350개
→ byIfcClass["IfcWall"]: 400개
→ byCategory["Walls"]: 380개
→ 합집합: 500개 후보

[Step 3] 샘플링
→ 분류 태그별 그룹핑:
  - "건축_골조_벽_RC": 250개
  - "건축_골조_벽_벽돌": 100개
  - "건축_골조_기초_RC": 150개 (IfcWall이지만 기초)
→ 각 그룹에서 3-4개씩 샘플링 → 총 10개

[Step 4] AI 필터 규칙 생성
→ filter_rules:
  - QM.classification_tag contains "벽"
  - QM.classification_tag not_contains "기초"

[Step 5] 필터 적용
→ 500개 후보 중 250개 매칭
→ 3D 뷰포트에서 250개 선택

[학습]
→ 성공적 쿼리 기록
→ byClassificationTag 우선순위 증가
```

### 예시 2: 조적공사 객체 선택

**사용자 쿼리**: "조적공사때 진행해야하는 객체를 다 선택해줘"

**실행 과정**:
```
[Step 1] AI 속성 결정
→ primary:
  - byClassificationTag["조적"]
  - byCostCodeName["조적공사"]
  - byActivity["조적공사"]

[Step 2] 후보 검색
→ byClassificationTag["조적"]: 80개
→ byCostCodeName["조적공사"]: 85개
→ byActivity["조적공사"]: 75개
→ 합집합: 90개 후보

[Step 3] 샘플링
→ 90개 < 10개 제한 → 모두 샘플로 사용

[Step 4] AI 필터 규칙 생성
→ filter_rules:
  - QM.classification_tag contains "조적" OR
  - CC.name contains "조적공사" OR
  - AC.name contains "조적공사"
(실제로는 AND가 아닌 OR 조건으로 구현 필요 - 향후 개선)

[Step 5] 필터 적용
→ 90개 모두 매칭
→ 3D 뷰포트에서 90개 선택

[학습]
→ 성공적 쿼리 기록
→ byCostCodeName, byActivity 우선순위 증가
```

## 향후 개선사항

### 1. OR 조건 지원
- 현재는 필터 규칙이 AND만 지원
- OR 조건 추가 필요 (예: "조적 OR 블록")

### 2. 숫자 비교 연산자
- `>`, `<`, `>=`, `<=` 연산자 추가
- 예: "면적이 10㎡ 이상인 벽"

### 3. Answer 액션 구현
- 현재는 Select만 구현
- 질문에 대한 텍스트 답변 생성

### 4. Section 액션 구현
- 단면상자 생성
- 기존 sketch mode 활용

### 5. AI 모델 튜닝
- 프로젝트별 특화 모델 학습
- 우선순위 자동 조정

### 6. 프롬프트 최적화
- 더 짧고 정확한 프롬프트
- Few-shot learning 예시 추가

### 7. 캐싱 고도화
- 쿼리 결과 캐싱
- 유사 쿼리 재사용

## 관련 파일

### 신규 생성
- `connections/static/connections/ai_index_builder.js`
- `connections/static/connections/ai_query_processor.js`
- `connections/static/connections/ai_select_handler.js`

### 수정
- `connections/templates/revit_control.html`
  - Line 3473-3478: AI 시스템 스크립트 추가

## 기술적 세부사항

### Property Inheritance Chain
```
BIM (RawElement)
  ↓ raw_data: { Attributes.IfcClass, Category, Family, Type, ... }
QuantityMember (QM)
  ↓ classification_tag, quantity, properties, ...
  ↓ member_mark_id → MemberMark (MM)
  ↓                    └─ name
CostItem (CI)
  ↓ cost_codes[] → CostCode (CC)
  ↓                 └─ code, name, detail_code
ActivityObject (AO)
  ↓ start_date, end_date, quantity
  ↓ activity_id → Activity (AC)
                   └─ code, name, duration
```

### 데이터 수집 함수
```javascript
collectObjectData(rawElementId) {
    return {
        id: rawElementId,
        BIM: { ...elem.raw_data },
        QM: [{ classification_tag, quantity, ... }],
        MM: [{ name, ... }],
        CI: [{ cost_codes, ... }],
        CC: [{ code, name, ... }],
        AO: [{ start_date, end_date, ... }],
        AC: [{ code, name, ... }]
    };
}
```

### 인덱스 구조
```javascript
indexes = {
    byIfcClass: Map {
        'IfcWall' => Set(['id1', 'id2', ...]),
        'IfcSlab' => Set(['id3', 'id4', ...]),
        ...
    },
    byClassificationTag: Map {
        '건축_골조_벽_RC' => Set(['id1', 'id5', ...]),
        ...
    },
    ...
}
```

## 작업 시간
- 날짜: 2025-11-07
- 소요 시간: 약 3시간
- 작업자: Claude Code (Anthropic)
- 이슈: AI 프롬프트 고도화 - 샘플링 및 학습 시스템
