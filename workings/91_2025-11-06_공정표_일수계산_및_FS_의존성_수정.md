# 2025-11-06: 공정표 일수 계산 및 FS 의존성 수정

## 작업 개요
공정계획 탭과 시뮬레이션 탭의 간트차트에서 일수 계산 방식을 통일하고, FS(Finish-to-Start) 의존성 처리 로직의 critical bug를 수정했습니다.

## 문제 상황

### 1. 공정계획 탭 vs 시뮬레이션 탭 일수 불일치
- **증상**: 같은 액티비티인데 공정계획 탭은 25일, 시뮬레이션 탭은 26일 표시
- **원인**: ActivityObject의 duration이 소수점일 때 처리 방식이 달랐음
  - 각 AO마다 개별적으로 `Math.ceil()` 적용 후 합산
  - 예: 0.5일 + 0.5일 → ceil(0.5) + ceil(0.5) = 1 + 1 = **2일** (잘못됨)
  - 올바른 계산: 0.5일 + 0.5일 = 1.0일 → ceil(1.0) = **1일**

### 2. Lag 일수 올림 처리 미적용
- **증상**: Lag가 2.5일이면 2.5일 그대로 적용됨
- **원인**: `parseFloat()`만 사용하고 올림 처리 없음
- **요구사항**: 양수 Lag는 올림, 음수 Lag는 내림 처리 필요

### 3. FS 의존성 날짜 계산 오류 (CRITICAL BUG)
- **증상**: FS + Lag=0 설정 시 선행공정 종료일 다음다음 날에 후행공정 시작
- **예상 동작**: 선행공정 종료일 → 다음 작업일에 후행공정 시작
- **실제 동작**: 선행공정 종료일 → 다음다음 작업일에 후행공정 시작
- **원인**: `addWorkingDays()` 함수의 근본적인 로직 오류
  - 시작일이 작업일이면 `daysAdded = 1`부터 시작
  - `workingDays = 0`일 때 while 루프 미실행 → 시작일 그대로 반환
  - 이로 인해 실제로는 +1일이 적용되는 효과

### 4. 액티비티 관리 탭 변경사항 미반영
- **증상**: 액티비티 관리에서 의존성 변경 후 공정계획 탭으로 이동해도 반영 안 됨
- **상태**: 디버깅 코드 추가하여 조사 중

## 수정 내용

### 1. Duration 집계 방식 변경 (`gantt_chart_handlers.js`)

#### 개별 AO 일수 계산 - 올림 제거 (Line 251-281)
```javascript
// BEFORE (잘못됨):
const durationDays = Math.max(1, Math.ceil(parseFloat(ao.actual_duration) ||
    (parseFloat(activity.duration_per_unit || 0) * parseFloat(ao.quantity || 0))));
activityDurationMap.set(activityId, activityDurationMap.get(activityId) + durationDays);

// AFTER (수정됨):
const durationDays = parseFloat(ao.actual_duration) ||
    (parseFloat(activity.duration_per_unit || 0) * parseFloat(ao.quantity || 0));
// 소수점 그대로 합산
activityDurationMap.set(activityId, activityDurationMap.get(activityId) + durationDays);
```

#### 최종 합계에만 올림 적용 (Line 287-321)
```javascript
activityDurationMap.forEach((totalDuration, activityId) => {
    // 최종 합계를 올림 처리 (최소 1일)
    const roundedDuration = Math.max(1, Math.ceil(totalDuration));

    const defaultStart = /* ... */;
    const defaultEnd = addWorkingDays(defaultStart, roundedDuration, taskCalendar);

    tasks.push({
        activityId,
        durationDays: roundedDuration, // 올림된 값 사용
        startDate: defaultStart,
        endDate: defaultEnd,
        // ...
    });
});
```

**효과**:
- 0.5일 + 0.5일 = 1.0일 → ceil(1.0) = 1일 ✅
- 0.3일 + 0.3일 + 0.3일 = 0.9일 → ceil(0.9) = 1일 ✅
- 1.2일 + 0.8일 = 2.0일 → ceil(2.0) = 2일 ✅

### 2. Lag 일수 올림 처리 추가 (Line 414-418)

```javascript
// BEFORE:
const lagDays = parseFloat(dep.lag_days || 0);
const adjustedDate = addWorkingDays(predEndDate, lagDays, predCalendar);

// AFTER:
const lagDaysRaw = parseFloat(dep.lag_days || 0);
const lagDays = lagDaysRaw >= 0 ? Math.ceil(lagDaysRaw) : Math.floor(lagDaysRaw);
const adjustedDate = addWorkingDays(predEndDate, lagDays, predCalendar);
```

**처리 방식**:
- 양수 Lag: 올림 (`Math.ceil()`)
  - 2.3일 → 3일
  - 0.5일 → 1일
- 음수 Lag: 내림 (`Math.floor()`)
  - -2.3일 → -3일
  - -0.5일 → -1일
- 0일: 그대로 0일

### 3. `addWorkingDays()` 함수 Critical Fix (Line 93-130)

이 수정이 가장 중요한 버그 픽스입니다.

#### 문제가 있던 기존 로직:
```javascript
function addWorkingDays(startDate, workingDays, calendar = null) {
    // ...
    let current = new Date(startDate);
    let daysAdded = 0;

    // BUG: 시작일이 작업일이면 daysAdded = 1부터 시작
    if (isWorkingDay(current, calendar)) {
        daysAdded = 1;
    }

    // workingDays = 0일 때 while 루프가 실행 안 됨
    // → 시작일 그대로 반환 (1일 전진한 효과)
    while (daysAdded < workingDays) {
        current.setDate(current.getDate() + 1);
        if (isWorkingDay(current, calendar)) {
            daysAdded++;
        }
    }

    return current;
}
```

**문제 시나리오**:
1. 선행공정 종료일: 2025-01-10 (금요일)
2. FS + Lag=0 → `addWorkingDays(2025-01-10, 0, calendar)` 호출
3. 기존 로직:
   - `daysAdded = 1` (시작일이 작업일이므로)
   - `while (1 < 0)` → 루프 실행 안 됨
   - `return 2025-01-10` ← **시작일 그대로 반환**
4. 후행공정 시작일: 2025-01-10
5. 하지만 실제 간트차트 렌더링에서 +1일 효과 발생 → 2025-01-11 표시
6. 추가 버그로 인해 실제로는 2025-01-12에 표시됨

#### 수정된 로직:
```javascript
function addWorkingDays(startDate, workingDays, calendar = null) {
    if (!calendar) {
        calendar = mainCalendar;
    }

    // 캘린더가 없으면 일반 날짜 추가
    if (!calendar) {
        return addDays(startDate, workingDays);
    }

    // ★ 핵심 수정: workingDays = 0인 경우 명시적 처리
    if (workingDays === 0) {
        // 0일 추가 = 다음 작업일 찾기
        let current = new Date(startDate);
        current.setDate(current.getDate() + 1); // 다음 날부터 시작

        // 다음 작업일 찾기
        while (!isWorkingDay(current, calendar)) {
            current.setDate(current.getDate() + 1);
        }

        return current;
    }

    let current = new Date(startDate);
    let daysAdded = 0;

    // ★ 핵심 수정: 시작일 다음 날부터 카운트 시작
    // (시작일을 1로 카운트하지 않음)
    while (daysAdded < workingDays) {
        current.setDate(current.getDate() + 1);
        if (isWorkingDay(current, calendar)) {
            daysAdded++;
        }
    }

    return current;
}
```

**수정 후 동작**:
1. 선행공정 종료일: 2025-01-10 (금요일)
2. FS + Lag=0 → `addWorkingDays(2025-01-10, 0, calendar)` 호출
3. 수정된 로직:
   - `workingDays === 0` 조건 충족
   - `current = 2025-01-11` (다음 날)
   - 2025-01-11이 토요일이면 → 2025-01-13 (월요일) 반환
   - 2025-01-11이 월요일이면 → 2025-01-11 그대로 반환
4. **결과**: 선행공정 종료일 다음 작업일에 후행공정 시작 ✅

**다른 케이스 검증**:
- `addWorkingDays(2025-01-10, 1, cal)`:
  - 다음 날부터 작업일 1일 카운트
  - 2025-01-11 (토) → Skip
  - 2025-01-12 (일) → Skip
  - 2025-01-13 (월) → 1일 카운트 → 반환

- `addWorkingDays(2025-01-10, 3, cal)`:
  - 2025-01-13 (월) → 1일
  - 2025-01-14 (화) → 2일
  - 2025-01-15 (수) → 3일 → 반환

### 4. 디버깅 코드 추가

#### 의존성 데이터 로깅 (Line 350-362)
```javascript
console.log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
console.log('[DEBUG] calculateTaskDates 시작');
console.log('[DEBUG] 총 태스크 수:', tasks.length);
console.log('[DEBUG] 총 의존성 수:', dependencies.length);
console.log('[DEBUG] 의존성 데이터:', dependencies.map(dep => ({
    선행: activityMap.get(dep.predecessor_activity)?.code || dep.predecessor_activity,
    후행: activityMap.get(dep.successor_activity)?.code || dep.successor_activity,
    lag: dep.lag_days,
    type: dep.dependency_type
})));
console.log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
```

#### 선행 작업 계산 상세 로깅 (Line 420-431)
```javascript
console.log(`[DEBUG] 의존성 계산:`, {
    선행작업: predTask.activity?.code || predTask.name,
    선행시작일: predStartDate.toISOString().split('T')[0],
    선행일수: predDuration,
    선행종료일: predEndDate.toISOString().split('T')[0],
    Lag원본: lagDaysRaw,
    Lag올림: lagDays,
    후행시작일: adjustedDate.toISOString().split('T')[0],
    캘린더: predCalendar?.name || '메인'
});
```

#### 최종 날짜 설정 로깅 (Line 462-470)
```javascript
console.log(`[DEBUG] 최종 날짜 설정:`, {
    액티비티: task.activity?.code || task.name,
    시작일: startDate.toISOString().split('T')[0],
    일수: task.durationDays,
    종료일: endDate.toISOString().split('T')[0],
    수동시작일: task.activity?.manual_start_date || '없음'
});
```

### 5. 간트차트 셀 렌더링 수정 (Line 694-701)

```javascript
// BEFORE:
const taskStartDay = Math.floor((startDate - minDate) / (1000 * 60 * 60 * 24));
const taskEndDay = Math.ceil((endDate - minDate) / (1000 * 60 * 60 * 24));

// AFTER:
const taskStartDay = Math.floor((startDate - minDate) / (1000 * 60 * 60 * 24));
const taskEndDay = taskStartDay + task.durationDays; // 직접 일수 추가
```

**이유**: 이미 올림 처리된 `task.durationDays`를 사용하므로 추가 계산 불필요

### 6. AO 개별 일수 표시 수정 (Line 1095-1101)

```javascript
// 소수점 포함 표시 (집계는 올림하지만 개별 항목은 소수점 표시)
const durationDays = (ao.actual_duration ||
    (parseFloat(activity.duration_per_unit || 0) * parseFloat(ao.quantity || 0))
).toFixed(2);
```

## 영향받는 파일

### 클라이언트
- `connections/static/connections/gantt_chart_handlers.js`
  - **Line 93-130**: `addWorkingDays()` 함수 critical fix
  - **Line 251-281**: AO 개별 일수 계산 올림 제거
  - **Line 287-321**: 최종 합계에만 올림 적용
  - **Line 350-362**: 의존성 데이터 디버깅 로그
  - **Line 414-418**: Lag 일수 올림 처리
  - **Line 420-431**: 선행 작업 계산 상세 로그
  - **Line 462-470**: 최종 날짜 설정 로그
  - **Line 694-701**: 간트차트 셀 렌더링 수정
  - **Line 1095-1101**: AO 개별 일수 소수점 표시

## 테스트 시나리오

### 1. Duration 집계 테스트
**입력**:
- Activity A: AO1 (0.5일) + AO2 (0.5일)
- Activity B: AO1 (1.2일) + AO2 (0.8일)

**예상 결과**:
- Activity A: 1일 (0.5 + 0.5 = 1.0 → ceil = 1)
- Activity B: 2일 (1.2 + 0.8 = 2.0 → ceil = 2)

### 2. Lag 올림 테스트
**입력**:
- Lag = 2.3일 → 3일
- Lag = -0.5일 → -1일
- Lag = 0일 → 0일

### 3. FS 의존성 테스트
**입력**:
- 선행공정 A: 2025-01-06(월) ~ 2025-01-10(금), 5일
- 후행공정 B: FS, Lag = 0

**예상 결과**:
- B 시작일: 2025-01-13(월) ← 금요일 다음 작업일

**입력 2**:
- 선행공정 A: 2025-01-06(월) ~ 2025-01-08(수), 3일
- 후행공정 B: FS, Lag = 2

**예상 결과**:
- A 종료: 2025-01-08(수)
- B 시작일: 2025-01-13(월) ← 수요일 + 2 작업일 = 금요일 → 다음 작업일 월요일

## 사용자 확인 필요 사항

1. **콘솔 로그 확인**:
   - 브라우저 새로고침 후 공정계획 탭 이동
   - DevTools 콘솔에서 `[DEBUG]` 로그 확인
   - 의존성 계산 과정 확인

2. **간트차트 시각적 확인**:
   - FS + Lag=0: 선행 종료일 다음 작업일에 후행 시작되는지 확인
   - 소수점 duration: 올림 처리된 결과가 맞는지 확인

3. **액티비티 관리 탭 동기화**:
   - 의존성 변경 후 공정계획 탭에 즉시 반영되는지 확인
   - 미반영 시 콘솔 로그 공유 필요

## 기술적 세부사항

### `addWorkingDays()` 함수 로직 변경 핵심

**기존 문제점**:
```
startDate가 작업일이면:
  daysAdded = 1로 시작 (startDate를 첫 번째 날로 카운트)

workingDays = 0이면:
  while (1 < 0) → 실행 안 됨
  return startDate (그대로)

→ 실제로는 startDate 다음 날이 되어야 하는데 startDate 반환
```

**수정 후**:
```
workingDays = 0이면:
  current = startDate + 1일
  while (!isWorkingDay(current)):
    current += 1일
  return current (다음 작업일)

workingDays > 0이면:
  daysAdded = 0으로 시작
  while (daysAdded < workingDays):
    current += 1일
    if (isWorkingDay(current)):
      daysAdded += 1
  return current

→ startDate를 카운트에 포함하지 않고 다음 날부터 카운트 시작
```

### Duration 집계 방식

```
[기존] 개별 올림 후 합산
AO1: 0.5일 → ceil(0.5) = 1일
AO2: 0.5일 → ceil(0.5) = 1일
합계: 1 + 1 = 2일 ❌

[수정] 합산 후 올림
AO1: 0.5일
AO2: 0.5일
합계: 0.5 + 0.5 = 1.0일 → ceil(1.0) = 1일 ✅
```

## 미해결 이슈

1. **액티비티 관리 탭 변경사항 미반영**:
   - 현상: 액티비티 관리에서 의존성 변경 후 공정계획 탭 이동 시 반영 안 됨
   - 조치: 디버깅 코드 추가 완료, 사용자 테스트 대기 중

## 다음 단계

1. 사용자가 브라우저 새로고침 후 테스트
2. 콘솔 로그 확인하여 디버깅 정보 수집
3. 미반영 이슈 해결을 위한 추가 조사

## 작업 시간
- 날짜: 2025-11-06
- 소요 시간: 약 1.5시간
- 작업자: Claude Code (Anthropic)
